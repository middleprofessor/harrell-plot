# "Harrell" or "horizontal" dot plot - defaults to ploting treatment contrasts
# in upper panel and treatment boxplots in lower planel
# Jeffrey A. Walker
# November 24, 2017

library(shiny)
library(gridExtra) # needed for download
library(ggplot2)
library(data.table)
library(Hmisc)
library(MCMCpack)
library(coda)
library(lsmeans)


# Define UI for application that draws a histogram
ui <- fluidPage(
  
  # sidebarLayout(
  # App title ----
  titlePanel("Hdotplot"),
  
  # Sidebar panel for inputs ----
  sidebarPanel(
    conditionalPanel(condition = "input.tabs=='Model'",
                     # Input file
                     fileInput("FileInput", "Choose file"),
                     
                     h3("Model"),
                     # reactive Input for treatment
                     uiOutput("treatment"),
                     # reactive Input for response
                     uiOutput("response"),
                     # reactive Input for grouping
                     uiOutput("group"),
                     
                     checkboxInput("interaction", "Add interaction", FALSE),
                     
                     # contrast method
                     selectInput("contrasts.method", h3("Contrasts"), 
                                 choices = list("Coefficients" = 1,"vs. Control" = 2, "Pairwise" = 3), selected = 2),
                     # Input: Checkbox for multiple tests
                     checkboxInput("adjust", "Adjust for multiple tests", FALSE),
                     # Input: Confidence level
                     selectInput("conf.contrast", h5("Confidence level"), 
                                 choices = list("99%" = 1, "95%" = 2, "90%" = 3), selected = 2),
                     # Input: Contrasts Confidence Interval Model
                     selectInput("intervals.contrast", h5("Contrasts CI model"), 
                                 choices = list("lm" = 1), selected = 1),
                     
                     selectInput("display.treatment", h3("Treatments"), 
                                 choices = list("Box plot" = 1, "Confidence Interval" = 2), selected = 1),
                     
                     # Input: Confidence level
                     selectInput("conf.mean", h5("Confidence level"), 
                                 choices = list("99%" = 1, "95%" = 2, "90%" = 3), selected = 2),
                     
                     # Input: Confidence Interval Model
                     # selectInput("intervals.mean", h5("Treatment CI model"), 
                     #       choices = list("raw" = 1, "lm" = 2, "bootstrap" = 3, "Bayesian" = 4), selected = 1),
                     selectInput("intervals.mean", h5("Treatment CI model"), 
                                 choices = list("raw" = 1, "lm" = 2, "bootstrap" = 3), selected = 1)
                     
                     
    ),
    
    conditionalPanel(condition = "input.tabs=='Plot'",
                     h3("Plot"),
                     # Input: colors
                     selectInput("colors", h5("Plot Colors"), 
                                 choices = list("ggplot" = 1, "Greys" = 2, "Blues" = 3,
                                                "Accent"=4, "Dark2"=5, "Set1"=6, "Set2"=7,
                                                "Set3"=8), selected = 2),
                     # Input: theme
                     selectInput("theme", h5("Plot Theme"), 
                                 choices = list("gray" = 1, "bw" = 2, "classic" = 3, 
                                                "minimal" = 4), selected = 4),
                     checkboxInput("hide.contrasts", "Hide contrasts", FALSE),
                     checkboxInput("hide.treatments", "Hide treatments", FALSE),
                     # Input: flip axes ----
                     checkboxInput("flip", "Horizontal bars", TRUE),
                     
                     # Input: abbreviate factor levels
                     checkboxInput("short", "Abbreviate factor levels", FALSE),
                     
                     # Input: Checkbox for dots ----
                     checkboxInput("dots", "Show dots", TRUE),
                     # Input: Checkbox for Mean
                     checkboxInput("mean", "Show Mean", FALSE)
                     
                     
    ),
    
    conditionalPanel(condition = "input.tabs=='Save'",
                     h3("Download"),
                     numericInput("width", "Width (inches)", 7, min = 2, max = 10, step = 0.25),
                     numericInput("height", "Height (inches)", 5, min = 2, max = 10, step = 0.25)
                     
    )
    
  ),
  
  # Main panel for displaying outputs ----
  mainPanel(
    
    tabsetPanel(type = "tabs",
                tabPanel("Model",
                         # Output: CI level and adjustment for contrasts
                         textOutput("interval_text"),
                         
                         # Output: Plot
                         plotOutput("hDotPlot.model", width = "100%", height = "600px")
                ),
                tabPanel("Plot",
                         # Output: Plot
                         plotOutput("hDotPlot.plot", width = "100%", height = "600px")
                ),
                tabPanel("Save",
                         
                         # print the plot
                         downloadButton(outputId = "downloadPlot", label = "Download the plot")
                ),
                id = 'tabs'
    )
    
  )
  #  )
)


# Define server logic to plot various variables against mpg ----
server <- function(input, output) {
  # global variable for downloading plot
  files <- reactiveValues(f1=FALSE)
  plots <- reactiveValues(p1=NULL)
  
  # populate Treatment input
  output$treatment <- renderUI({
    df <-datasetInput()
    if (is.null(df)) return(NULL)
    items=c(' ', names(df))
    #    names(items)=items
    selectInput("treatment", "Treatment",items)
  })
  
  # populate Response input
  output$response <- renderUI({
    df <-datasetInput()
    if (is.null(df)) return(NULL)
    items=c(' ', names(df))
    #    names(items)=items
    selectInput("response", "Response",items)
  })
  
  # populate Group input
  output$group <- renderUI({
    df <-datasetInput()
    if (is.null(df)) return(NULL)
    items=c(' ', names(df))
    #    names(items)=items
    selectInput("group", "Grouping",items)
  })
  
  
  #  the function to plot the data
  # read data file
  datasetInput <- reactive({
    infile <- input$FileInput
    if(is.null(infile))
      return(NULL)
    files$f1 <- TRUE
    fread(infile$datapath, stringsAsFactors = TRUE)
  })
  
  form <- function(y, xcols){
    form_str <- paste(y, ' ~ ', paste(xcols, collapse=' + '), sep='')
    # if(input$interaction==TRUE & length(xcols)==2){
    #   form_str <- paste(form_str, paste(xcols[1],':',xcols[2], sep=''), sep = ' + ')
    # }
    return(form_str)
  }
  
  plotInput <- function(){
    df <-datasetInput()
    if (is.null(df) | input$treatment==' ' | input$response==' ') return(NULL)
    dt <- data.table(x = factor(df[[input$treatment]]), g = '', y = df[[input$response]])
    
    if(is.numeric(df[[input$response]])){
      #set inputs to non-shiny variables
      # confidence limits for contrasts and means
      conf <- c(0.99, 0.95, 0.9)
      conf.contrast <- conf[as.numeric(as.character(input$conf.contrast))]
      conf.mean <- conf[as.numeric(as.character(input$conf.mean))]
      
      # contrasts
      # method for computation of treatment CI
      interval_array <- c('lm','boot','bayes')
      intervals.contrast <- interval_array[as.numeric(as.character(input$intervals.contrast))]
      # control or pairwise contrasts
      contrast_array <- c('coefficients','trt.vs.ctrl1', 'revpairwise') # c("Control", "Pairwise") in menu 
      contrasts.method <- contrast_array[as.numeric(as.character(input$contrasts.method))]
      # adjust for multiple tests
      adjust <- ifelse(input$adjust==TRUE, TRUE, FALSE)
      add_interaction <- ifelse(input$interaction==TRUE, TRUE, FALSE)
      
      # treatments
      input_array <- c('box','ci')
      display.treatment <- input_array[as.numeric(as.character(input$display.treatment))]
      # method for computation of treatment CI
      interval_array <- c('raw','lm','boot','bayes')
      intervals.mean <- interval_array[as.numeric(as.character(input$intervals.mean))]
      
      # grouping
      if(input$group==' '){grouping <- FALSE}else{grouping <- TRUE}
      
      # plot
      color_array <- c("ggplot", "Greys", "Blues", "Accent", "Dark2", "Set1", "Set2", "Set3")
      color_palette <- color_array[as.numeric(as.character(input$colors))]
      theme_array <- c("gray", "bw", "classic", "minimal")
      jtheme <- theme_array[as.numeric(as.character(input$theme))]
      show.treatments <- ifelse(input$hide.treatments==FALSE, TRUE, FALSE)
      show.contrasts <- ifelse(input$hide.contrasts==FALSE, TRUE, FALSE)
      show.mean <- ifelse(input$mean==TRUE, TRUE, FALSE)
      
      if(input$short==FALSE){short <- FALSE}else{short <- TRUE}
      
      xcols <- 'x'
      if(grouping == TRUE){
        dt[,g:=factor(df[[input$group]])]
        xcols <- c('x','g')
      }
      dt <- na.omit(dt)
      if(short==TRUE){
        dt[,x:=abbreviate(x)]
        dt[,g:=abbreviate(g)]
      }
      dt[,x:=factor(x, dt[,.(i=min(.I)),by=x][,x])]
      dt[,g:=factor(g, dt[,.(i=min(.I)),by=g][,g])]
      ybar <- mean(dt[,y]) # needed to shift contrasts for double-Y plot
      
      
      if(add_interaction==TRUE){
        form <- formula(paste('y ~ ', paste(xcols, collapse='*'), sep=''))
      }else{
        form <- formula(paste('y ~ ', paste(xcols, collapse=' + '), sep=''))
      }
      
      fit <- lm(form, data=dt)
      lsm <- lsmeans(fit, specs=xcols)
      
      #     Bayes model
      #  mad <- median(abs(dt[,y] - mean(dt[,y])))
      #  #dt[,y.mad:=y/mad]
      #  y.mad <- dt[,y]/mad
      #  fit.mcmc <- MCMCregress(y.mad ~ x, data=dt, b0 = 0, B0 = 0.1, c0=2, d0=0.11)
      #  post.lsm <- lsmeans(fit.mcmc, specs='x')
      # # dt <- dt[, .SD, .SDcols=c('x','y')] #drop y.mad because need to bind ci later
      
      # means intervals
      if(intervals.mean=='lm'){
        ci_means <- data.table(confint(lsm, level=conf.mean)) # mean intervals not adjusted
        ci_means <- ci_means[, .SD, .SDcols=c(xcols,'lsmean','lower.CL','upper.CL')]
      }
      if(intervals.mean=='raw'){
        conf.tail <- conf.mean + (1-conf.mean)/2
        ci_means <- dt[, .(
          mean=mean(y),
          lower=mean(y)-sd(y)/sqrt(.N)*qt(conf.tail,(.N-1)),
          upper=mean(y)+sd(y)/sqrt(.N)*qt(conf.tail,(.N-1))),
          by=xcols]
      }
      if(intervals.mean=='boot'){
        dt_boot <- data.table(dt[, smean.cl.boot(y,conf.int=conf.mean), by=xcols])
        dt_boot[, tile:=c('a','lower','upper')]
        form <- formula(paste(paste(xcols,collapse='+'),'tile',sep='~'))
        ci_means <- dcast(dt_boot, form, value.var='V1') #**** change x+g to formula
      }
      if(intervals.mean=='bayes'){
        conf.tail <- conf.mean + (1-conf.mean)/2
        res <- summary(as.mcmc(post.lsm), quantiles = c(0.5, (1-conf.tail), conf.tail))$quantiles*mad
        ci_means <- data.table(x=row.names(res),res)
        ci_means[, x:=factor(substr(x,3,nchar(x)))]
      }
      if(grouping==FALSE){
        ci_means[, g:='']
        setnames(ci_means, old=colnames(ci_means), new=c('x','y','lower','upper','g'))
        ci_means <- ci_means[,.SD, .SDcols=c('x','g','y','lower','upper')]
      }else{
        setnames(ci_means, old=colnames(ci_means), new=c(xcols,'y','lower','upper'))
      }
      
      #     contrast intervals
      m_levels <- levels(dt[,x]) # levels for means plot
      g_levels <- levels(dt[,g])
      n_levels <- length(m_levels)
      n_groups <- length(g_levels)
      
      if(contrasts.method=='coefficients'){
        ci_diffs <- coefficients(summary(fit))[-1,]
        x_names <- c(levels(dt$x)[-1],levels(dt$g)[-1])
        if(add_interaction==TRUE){
          temp <- expand.grid(levels(dt$x)[-1],levels(dt$g)[-1])
          x_names <- c(x_names, paste(temp$Var1, temp$Var2, sep=':'))
        }
        ci_diffs <- data.table(contrast=x_names, g=NA, ci_diffs, confint(fit, level=conf.contrast)[-1,])
        temp <- confint(fit, level=conf.contrast)[-1,]
        setnames(ci_diffs, old=colnames(ci_diffs), new = c('contrast', 'g', 'estimate', 'Std. Error', 't value', 'Pr(>|t|)', 'lower', 'upper'))
        ci_diffs <- ci_diffs[, .SD, .SDcols=c('contrast','g','estimate','lower','upper')]
        ci_diffs[, contrast:=factor(contrast, levels=x_names)]
      }
      if(intervals.contrast=='lm' & contrasts.method!='coefficients'){
        ci.adjust <- 'none'
        if(adjust==TRUE){
          ci.adjust <- ifelse(contrasts.method=='trt.vs.ctrl1', 'dunnettx','tukey')
        }
        if(grouping==FALSE | add_interaction==TRUE){
          ci_diffs <- data.table(confint(contrast(lsm, method=contrasts.method), adjust=ci.adjust, level=conf.contrast))
          ci_diffs[, g:=NA]
        }
        if(grouping==TRUE & add_interaction==FALSE){
          if(contrasts.method=='revpairwise'){
            p_levels <- n_levels*(n_levels-1)/2
            p_groups <- n_groups*(n_groups-1)/2
          }else{
            p_levels <- n_levels-1
            p_groups <- n_groups-1
          }
          ci_diff.x <- data.table(confint(contrast(lsm, method=contrasts.method, by='g'), adjust='none', level=conf.contrast))[1:p_levels]
          ci_diff.x[, g:=input$treatment]
          ci_diff.g <- data.table(confint(contrast(lsm, method=contrasts.method, by='x'), adjust='none', level=conf.contrast))[1:p_groups]
          setnames(ci_diff.g, old=c('x'), new='g')
          ci_diff.x[, g:=input$group]
          ci_diffs <- rbind(ci_diff.x, ci_diff.g)
        }
        ci_diffs <- ci_diffs[, .SD, .SDcols=c('contrast','g','estimate','lower.CL','upper.CL')]
      }
      if(intervals.contrast=='bayes'){
        conf.tail <- conf.contrast + (1-conf.contrast)/2
        res <- summary(as.mcmc(contrast(post.lsm, method=contrasts.method)), quantiles = c(0.5, (1-conf.tail), conf.tail))$quantiles*mad
        ci_diffs <- data.table(x=row.names(res),res)
        ci_diffs[, x:=factor(substr(x,10,nchar(x)))]
      }
      
      setnames(ci_diffs, old=colnames(ci_diffs), new=c('x','g','y','lower','upper'))
      
      ci_diffs[, y:=y+ybar] # will be corrected by sec.axis in ggplot
      ci_diffs[, lower:=lower+ybar] # will be corrected by sec.axis in ggplot
      ci_diffs[, upper:=upper+ybar] # will be corrected by sec.axis in ggplot
      
      # make a dummy x for categorical variables for means
      c_levels <- levels(ci_diffs[,x]) # levels for contrast plot
      n_contrasts <- length(c_levels)
      width <- 0.8
      offset <- mean(1:n_groups/n_groups)
      contraction <- 1/ceiling(n_groups/2)
      dt[, x.d:=as.numeric(factor(x))]
      dt[, x.d:=(x.d + width*(as.numeric(factor(g))/n_groups - offset))]
      ci_means[, x.d:=as.numeric(factor(x))]
      ci_means[, x.d:=(x.d + width*(as.numeric(factor(g))/n_groups - offset))]
      contrast_breaks <- seq(from=(n_levels+1), to=(n_levels+1 + n_contrasts*contraction - contraction), by=contraction)
      ci_diffs[, x.d:= contrast_breaks]
      
      dt <- rbind(data.table(estimate='means',dt),
                  data.table(estimate='contrasts',ci_diffs[,.SD,.SDcols=c('x','g','y','x.d')]))
      ci <- rbind(data.table(estimate='means',ci_means),
                  data.table(estimate='contrasts',ci_diffs))
      dt[, x.fac:=x]
      ci[, x.fac:=x]
      dt[, x:=x.d]
      ci[, x:=x.d]
      
      # set x-axis breaks and bounds
      # breaks = 1:hi, label=levels(dt[,x.fac][lo:hi]), limits = c((lo-0.5), (hi+0.5)),
      if(show.treatments == FALSE){
        lo <- NA
        hi <- NA
        breaks <- NULL
        break_labels <- NULL
      }else{
        lo <- min(dt[, x])
        hi <- max(dt[estimate=='means', x])
        breaks <- 1:n_levels
        break_labels <- m_levels
      }
      if(show.contrasts == TRUE){
        if(is.na(lo)){
          lo <- n_levels+1
        }
        hi <- max(dt[, x])
        breaks <- c(breaks, contrast_breaks)
        break_labels <-c(break_labels, c_levels)
      }
      guide.boxplot <- FALSE
      guide.dots <- FALSE
      if(grouping==TRUE){
        #guide.boxplot <- ifelse(display.treatment=='box',TRUE,FALSE)
        guide.boxplot <- TRUE
        guide.dots <- ifelse(guide.boxplot==TRUE,FALSE,TRUE)
      }

      # x transformed to x.d and categorical x put into x.fac above 
      gg <- ggplot(data=dt, aes(x=x, y=y))
      
      # plot dots/mean/boxplot
      if(show.treatments == TRUE){
        #        for(i in 1:n_groups){
        if(display.treatment=='box'){ # plot before dots
          if(input$dots==TRUE){outlier_color <- NA}else{outlier_color <- NULL}
          gg <- gg + geom_boxplot(data=dt[estimate=='means',], aes(group=x, fill=g), outlier.colour = outlier_color, show.legend = guide.boxplot)
          if(guide.boxplot==TRUE){gg <- gg + guides(fill = guide_legend(input$group))}else{
            gg <- gg + guides(fill=FALSE)
          }
        }
        if(input$dots==TRUE){
          gg <- gg + geom_jitter(data=dt[estimate=='means',], aes(x=x,y=y, color=g), width = (0.8*0.5)/n_groups/2, height = 0.0, show.legend = guide.dots, color='black')
          if(guide.dots==TRUE){gg <- gg + guides(color = guide_legend(input$group))}else{
            gg <- gg+ guides(color=FALSE)
          }
        }
        if(display.treatment=='ci'){
          gg <- gg + geom_linerange(data=ci[estimate=='means',], aes(ymin = lower, ymax = upper, color=g), size=2)
          if(guide.boxplot==TRUE){gg <- gg + guides(color = guide_legend(input$group))}else{
            gg <- gg + guides(color=FALSE)
          }
        }
        if(show.mean==TRUE){
          gg <- gg + geom_point(data=ci[estimate=='means',], aes(x=x,y=y), size=3, color='white')
          gg <- gg + geom_point(data=ci[estimate=='means',], aes(x=x,y=y), size=2, color='black')
        }
      }
      
      # plot contrasts
      if(show.contrasts == TRUE){
        gg <- gg + geom_linerange(data=ci[estimate=='contrasts',], aes(ymin = lower, ymax = upper), color='black', size=2)
        gg <- gg + geom_point(data=ci[estimate=='contrasts',], aes(x=x,y=y), size=3, color='white')
        gg <- gg + geom_point(data=ci[estimate=='contrasts',], aes(x=x,y=y), size=2, color='black')
        gg <- gg + scale_y_continuous(sec.axis = sec_axis(~.-ybar, name = "Difference"))
        if(show.treatments == TRUE){
          gg <- gg + geom_vline(xintercept=n_levels+0.5, size=1, color='darkgrey')
        }
      }
      
      gg <- gg + labs(x=input$treatment, y=input$response)
      
      # build X axes
      pos_labels <- c((n_levels+1)/2, median(contrast_breaks))
      contrast_txt <- ifelse(contrasts.method=='coefficients', 'Coefficient', 'Contrast')
      gg <- gg + scale_x_continuous(
        breaks = breaks, label=break_labels, 
        # limits = c((lo-contraction/2), (hi+contraction/2)),
        sec.axis = sec_axis(~.+0, breaks=pos_labels, labels=c(input$treatment, contrast_txt)))
      
      # set colors
      if(color_palette != 'ggplot'){
        gg <- gg + scale_color_brewer(palette = color_palette)
        gg <- gg + scale_fill_brewer(palette = color_palette)
        }
      
      # set theme
      if(jtheme=='grey'){gg <- gg + theme_grey(base_size = 18)}
      if(jtheme=='gray'){gg <- gg + theme_gray(base_size = 18)}
      if(jtheme=='bw'){gg <- gg + theme_bw(base_size = 18)}
      if(jtheme=='classic'){gg <- gg + theme_classic(base_size = 18)}
      if(jtheme=='minimal'){gg <- gg + theme_minimal(base_size = 18)}
      
      if(input$flip==TRUE){
        gg <- gg + coord_flip()
        gg <- gg + theme(axis.title.y = element_blank(),
                         axis.text.y.right= element_text(angle = -90, hjust = 0.5),
                         legend.position = 'bottom')
      }else{
        gg <- gg + theme(axis.title.x = element_blank())
      }
      
      
      plots$p1 <- gg
      gg
      
      
    }
  }
  
  
  # output contrast interval method
  output$interval_text <- renderText({
    if(files$f1==FALSE) return(NULL)
    df <-datasetInput()
    if (is.null(df)) return(NULL)
    
    if(input$intervals.contrast!=1){ #bootstrap or bayes
      adjust_text <- 'no'
    }else{
      if(input$adjust==FALSE){adjust_text <- 'none'}else{
        adjust_text <- ifelse(input$contrasts.method==2, 'Dunnet t approximation','Tukey HSD')
      }
    }
    conf <- c(0.99, 0.95, 0.9)
    conf.contrast <- as.integer(conf[as.numeric(as.character(input$conf.contrast))]*100)
    out_text <- paste('contrasts with ',conf.contrast,'% CI using adjustment: ',adjust_text, sep='')
    out_text
  })
  
  # plot to the main panel
  output$hDotPlot.model <- renderPlot({
    if(files$f1==FALSE) return(NULL)
    print(plotInput())
  })  
  
  # plot to the main panel
  output$hDotPlot.plot <- renderPlot({
    if(files$f1==FALSE) return(NULL)
    print(plotInput())
  })  
  
  # download
  # output$downloadPlot <- downloadHandler(
  #   filename = 'temp.png',
  #   content = function(file) {
  #     device <- function(..., width, height) grDevices::png(..., width = width, height = height, res = 300, units = "in")
  #     ggsave(file, plot = plotInput(), device = device)
  #   }
  # )
  
  output$downloadPlot = downloadHandler(
    filename = function() {"Hdotplot.pdf"},
    content = function(file) {
      pdf(file, width=input$width, height=input$height, onefile = TRUE)
      grid.arrange(plots$p1) 
      dev.off()
    }
  )
  
}


# Run the application 
shinyApp(ui = ui, server = server)

s