# "Harrell" or "horizontal" dot plot - defaults to ploting treatment contrasts
# in upper panel and treatment boxplots in lower planel
# Jeffrey A. Walker
# November 24, 2017
# note See https://github.com/thomasp85/patchwork/blob/master/README.md for alternative to Hdotplot
# working07 - added anova, 
# working08 - (1) made Hdotplot a modular function that can be used in R package without shiny. (2) changed dt from colnames=c(x, g, y) to actual variable names. (3) moved global variables tables, code to local, (4) added dashed line at y=0 to contrast part of plot
# working09 - added ability to view contrasts within treatment and within group 

library(shiny)
library(gridExtra) # needed for download
library(ggplot2)
library(broom)
library(lsmeans)
library(car)
library(data.table)
library(Hmisc) # smean.cl.boot
library(MCMCpack) # bayes
library(coda) # bayes


# Define UI for application that draws a histogram
ui <- fluidPage(
  
  # sidebarLayout(
  # App title ----
  titlePanel("Hdotplot"),
  
  # Sidebar panel for inputs ----
  sidebarPanel(
    conditionalPanel(condition = "input.tabs=='Model'",
                     # Input file
                     fileInput("FileInput", "Choose file"),
                     
                     #h3("Model"),
                     selectInput("model", h3("Model"), choices=c('lm'), selected = 1),
                     # response distribution
                     selectInput("error", "Error Distribution", choices=c('Normal'), selected = 1),
                     
                     # reactive Input for treatment
                     uiOutput("treatment"),
                     # reactive Input for response
                     uiOutput("response"),
                     # reactive Input for grouping
                     uiOutput("group"),
                     # reactive interaction checkbox
                     uiOutput("interaction"),
                     uiOutput("interaction.treatment"),
                     uiOutput("interaction.group"),
                     
                     # contrast method
                     selectInput("contrasts.method", h3("Contrasts"), 
                                 choices = list("Coefficients" = 1,"vs. Control" = 2, "Pairwise" = 3), selected = 2),
                     # Input: Checkbox for multiple tests
                     checkboxInput("adjust", "Adjust for multiple tests", FALSE),
                     # Input: Confidence level
                     selectInput("conf.contrast", h5("Confidence level"), 
                                 choices = list("99%" = 1, "95%" = 2, "90%" = 3), selected = 2),
                     selectInput("display.treatment", h3("Treatments"), 
                                 choices = list("Box plot" = 1, "Confidence Interval" = 2), selected = 1),
                     
                     # Input: Confidence level
                     selectInput("conf.mean", h5("Confidence level"), 
                                 choices = list("99%" = 1, "95%" = 2, "90%" = 3), selected = 2),
                     
                     # Input: Confidence Interval Model
                     # selectInput("mean_intervals.method", h5("Treatment CI model"), 
                     #       choices = list("raw" = 1, "lm" = 2, "bootstrap" = 3, "Bayesian" = 4), selected = 1),
                     selectInput("mean_intervals.method", h5("Treatment CI model"), 
                                 choices = list("raw" = 1, "model" = 2, "bootstrap" = 3), selected = 1)
                     
                     
    ),
    
    conditionalPanel(condition = "input.tabs=='Plot'",
                     h3("Plot"),
                     # Input: colors
                     selectInput("colors", h5("Plot Colors"), 
                                 choices = list("ggplot" = 1, "Greys" = 2, "Blues" = 3,
                                                "Accent"=4, "Dark2"=5, "Set1"=6, "Set2"=7,
                                                "Set3"=8), selected = 2),
                     # Input: theme
                     selectInput("theme", h5("Plot Theme"), 
                                 choices = list("gray" = 1, "bw" = 2, "classic" = 3, 
                                                "minimal" = 4), selected = 4),
                     checkboxInput("hide.contrasts", "Hide contrasts", FALSE),
                     checkboxInput("hide.treatments", "Hide treatments", FALSE),
                     # Input: flip axes ----
                     checkboxInput("horizontal", "Horizontal bars", TRUE),
                     
                     # Input: abbreviate factor levels
                     checkboxInput("short", "Abbreviate factor levels", FALSE),
                     
                     # Input: Checkbox for dots ----
                     checkboxInput("dots", "Show dots", TRUE),
                     # Input: Checkbox for Mean
                     checkboxInput("mean", "Show Mean", TRUE)
                     
                     
    ),
    
    conditionalPanel(condition = "input.tabs=='Table'",
                     h3("Tables"),
                     checkboxInput("notPretty", "Raw R tables", FALSE)
                     
    ),
    
    conditionalPanel(condition = "input.tabs=='Save'",
                     h3("Download"),
                     numericInput("width", "Width (inches)", 7, min = 2, max = 10, step = 0.25),
                     numericInput("height", "Height (inches)", 5, min = 2, max = 10, step = 0.25)
                     
    )
    
  ),
  
  # Main panel for displaying outputs ----
  mainPanel(
    
    tabsetPanel(type = "tabs",
                tabPanel("Model",
                         # Output: CI level and adjustment for contrasts
                         textOutput("interval_text"),
                         
                         # Output: Plot
                         plotOutput("hDotPlot.model", width = "100%", height = "600px")
                ),
                tabPanel("Plot",
                         # Output: Plot
                         plotOutput("hDotPlot.plot", width = "100%", height = "600px")
                ),
                tabPanel("Table",
                         textOutput("formulaCaption"),
                         verbatimTextOutput("modelFormula"),
                         textOutput("contrastsCaption"),
                         verbatimTextOutput("modelContrasts"),
                         textOutput("sumCaption"),
                         verbatimTextOutput("modelSummary"),
                         textOutput("coefCaption"),
                         verbatimTextOutput("modelCoefficients"),
                         textOutput("meansCaption"),
                         verbatimTextOutput("modelMeans"),
                         textOutput("anovaCaption"),
                         verbatimTextOutput("modelAnova1"),
                         verbatimTextOutput("modelAnova2"),
                         verbatimTextOutput("modelAnova3")
                ),
                tabPanel("Code",
                         htmlOutput("modelCode")
                ),
                tabPanel("Save",
                         
                         # print the plot
                         downloadButton(outputId = "downloadPlot", label = "Download the plot")
                ),
                id = 'tabs'
    )
    
  )
  #  )
)

server <- function(input, output) {
  # global variable for downloading plot
  plots <- reactiveValues(p1=NULL)
  # tables <- reactiveValues(form_str=NULL, fit=NULL, coeffs=NULL, summary=NULL, means=NULL, diffs=NULL, anova.1=NULL, anova.2=NULL, anova.3=NULL)
  # codes <- reactiveValues(fit=NULL, data=NULL)
  
  # read data file
  dataInput <- reactive({
    infile <- input$FileInput # opens file browser
    if(is.null(infile))
      return(NULL)
    df <- fread(infile$datapath, stringsAsFactors = TRUE)
    return(df)
  })
  
  # populate Treatment input
  output$treatment <- renderUI({
    df <-dataInput()
    if (is.null(df)) return(NULL)
    items=c(' ', names(df))
    #    names(items)=items
    selectInput("treatment", "Treatment",items)
  })
  
  # populate Response input
  output$response <- renderUI({
    df <-dataInput()
    if (is.null(df)) return(NULL)
    items=c(' ', names(df))
    #    names(items)=items
    selectInput("response", "Response",items)
  })
  
  # populate Group input
  output$group <- renderUI({
    df <-dataInput()
    if (is.null(df)) return(NULL)
    items=c('None', names(df))
    #    names(items)=items
    selectInput("group", "Grouping", items, selected=1)
  })
  
  output$interaction <- renderUI({
    df <-dataInput()
    if (is.null(df)) return(NULL)
    if (input$group=='None') return(NULL)
    checkboxInput("interaction", "Add interaction", FALSE)
  })

  output$interaction.treatment <- renderUI({
    df <-dataInput()
    if (is.null(df)) return(NULL)
    if (input$group=='None') return(NULL)
    checkboxInput("interaction.treatment", "within Treatment", TRUE)
  })

    output$interaction.group <- renderUI({
    df <-dataInput()
    if (is.null(df)) return(NULL)
    if (input$group=='None') return(NULL)
    checkboxInput("interaction.group", "within Group", FALSE)
  })
  
  round_df <- function(df, digits){
    df_names <- colnames(df)
    df <- data.frame(lapply(df, function(y) if(is.numeric(y)) round(y, digits) else y)) 
    colnames(df) <- df_names
    return(df)
  }
  
  form <- function(y, xcols){
    form_str <- paste(y, ' ~ ', paste(xcols, collapse=' + '), sep='')
    # if(input$interaction==TRUE & length(xcols)==2){
    #   form_str <- paste(form_str, paste(xcols[1],':',xcols[2], sep=''), sep = ' + ')
    # }
    return(form_str)
  }
  
  fit_model <- function(
    x,
    y,
    g,
    dt,
    fit.model='lm', # lm, glm
    error='Normal', # normal, lognormal, logistic, poisson
    add_interaction=FALSE,
    interaction.group=FALSE,
    interaction.treatment=TRUE,
    mean_intervals.method='lm', # model for CI of mean
    conf.mean=0.95, # confidence level for CI of mean
    contrasts.method='coefficients', # which contrasts to show
    conf.contrast=0.95,
    adjust=FALSE
  ){
    if(g=='dummy_g'){
      xcols <- x
      grouping <- FALSE
    }else{
      xcols <- c(x,g)
      grouping <- TRUE
    }
    
    if(add_interaction==TRUE){
      model_formula <- formula(paste(y,' ~ ', paste(xcols, collapse='*'), sep=''))
      code.fit <- c("model_formula <- formula(paste(y,' ~ ', paste(xcols, collapse='*'), sep=''))")
    }else{
      model_formula <- formula(paste(y,' ~ ', paste(xcols, collapse=' + '), sep=''))
      code.fit <- c("model_formula <- formula(paste(y,' ~ ', paste(xcols, collapse=' + '), sep=''))")
    }
    if(fit.model=='lm'){
      fit <- lm(model_formula, data=dt)
    }
    if(fit.model=='glm'){
      fit <- lm(model_formula, data=dt)
    }
    lsm <- lsmeans(fit, specs=xcols)
    
    # save global
    tables <- list(NULL)
    tables$fit <- fit
    tables$form_str <- model_formula
    tables$coeffs <- coefficients(summary(fit))
    tables$summary <- glance(fit)
    tables$anova.1 <- anova(fit)
    tables$anova.2 <- Anova(fit, type='II')
    options(contrasts=c(unordered="contr.sum", ordered="contr.poly"))
    tables$anova.3 <- Anova(lm(model_formula, data=dt), type='III')
    options(contrasts=c(unordered="contr.treatment", ordered="contr.poly"))
    
    # code
    code.fit <- c(code.fit, "fit <- lm(model_formula, data=dt)",
                  "lsm <- lsmeans(fit, specs=xcols)")
    
    #     Bayes model
    #  mad <- median(abs(dt[,y] - mean(dt[,y])))
    #  #dt[,y.mad:=y/mad]
    #  y.mad <- dt[,y]/mad
    #  fit.mcmc <- MCMCregress(y.mad ~ x, data=dt, b0 = 0, B0 = 0.1, c0=2, d0=0.11)
    #  post.lsm <- lsmeans(fit.mcmc, specs='x')
    # # dt <- dt[, .SD, .SDcols=c('x','y')] #drop y.mad because need to bind ci later
    
    # means intervals
    if(mean_intervals.method=='lm'){
      tables$means <- confint(lsm, level=conf.mean)
      ci_means <- data.table(tables$means) # mean intervals not adjusted
      ci_means <- ci_means[, .SD, .SDcols=c(xcols,'lsmean','lower.CL','upper.CL')]
    }
    if(mean_intervals.method=='raw'){
      conf.tail <- conf.mean + (1-conf.mean)/2
      tables$means <- dt[, .(
        mean=mean(get(y)),
        sem=sd(get(y))/sqrt(.N),
        lower=mean(get(y))-sd(get(y))/sqrt(.N)*qt(conf.tail,(.N-1)),
        upper=mean(get(y))+sd(get(y))/sqrt(.N)*qt(conf.tail,(.N-1))),
        by=xcols]
      ci_means <- tables$means[, .SD, .SDcols=c(xcols,'mean', 'lower','upper')]
    }
    if(mean_intervals.method=='boot'){
      dt_boot <- data.table(dt[, smean.cl.boot(get(y),conf.int=conf.mean), by=xcols])
      dt_boot[, tile:=c('a','lower','upper')]
      form <- formula(paste(paste(xcols,collapse='+'),'tile',sep='~'))
      ci_means <- dcast(dt_boot, form, value.var='V1') #**** change x+g to formula
    }
    # if(mean_intervals.method=='bayes'){
    #   conf.tail <- conf.mean + (1-conf.mean)/2
    #   res <- summary(as.mcmc(post.lsm), quantiles = c(0.5, (1-conf.tail), conf.tail))$quantiles*mad
    #   ci_means <- data.table(x=row.names(res),res)
    #   ci_means[, (x):=factor(substr(x,3,nchar(x)))]
    # }
    if(grouping==FALSE){
      ci_means[, (g):='dummy']
      setnames(ci_means, old=colnames(ci_means), new=c(x, y, 'lower', 'upper', g))
      ci_means <- ci_means[,.SD, .SDcols=c(x, g, y,'lower','upper')]
    }else{
      setnames(ci_means, old=colnames(ci_means), new=c(xcols, y, 'lower','upper'))
    }
    
    #     contrast intervals
    x_levels <- levels(dt[, get(x)]) # levels for means plot
    g_levels <- levels(dt[, get(g)])
    n_levels <- length(x_levels)
    n_groups <- length(g_levels)
    
    if(contrasts.method=='coefficients'){
      ci_diffs <- coefficients(summary(fit))
      x_names <- c(x_levels[-1], g_levels[-1])
      if(add_interaction==TRUE){
        temp <- expand.grid(x_levels[-1], g_levels[-1])
        x_names <- c(x_names, paste(temp$Var1, temp$Var2, sep=':'))
      }
      ci_diffs <- cbind(ci_diffs, confint(fit, level=conf.contrast))
      tables$contrasts <- data.table(contrast=x_names, ci_diffs[-1,])
      ci_diffs <- data.table(contrast=x_names, g='dummy', ci_diffs[-1,])
      setnames(ci_diffs, old=colnames(ci_diffs), new = c('contrast', 'g', 'estimate', 'Std. Error', 't value', 'Pr(>|t|)', 'lower', 'upper'))
      ci_diffs <- ci_diffs[, .SD, .SDcols=c('contrast','g','estimate','lower','upper')]
      ci_diffs[, contrast:=factor(contrast, levels=x_names)]
    }
    if(fit.model=='lm' & contrasts.method!='coefficients'){
      ci.adjust <- 'none'
      if(adjust==TRUE){
        ci.adjust <- ifelse(contrasts.method=='trt.vs.ctrl1', 'dunnettx','tukey')
      }
      if(grouping==FALSE | add_interaction==TRUE){
        ci_diffs <- summary(contrast(lsm, method=contrasts.method), adjust=ci.adjust, level=conf.contrast, infer=c(TRUE,TRUE))
        if(grouping==TRUE & contrasts.method=='revpairwise'){ # subset into pairwise within each group
          # another method
          # fread(paste(as.character(ci_diffs$contras), collapse='\n'), sep='-')
          inc <- NULL
          split1 <- data.frame(t(do.call("cbind", strsplit(as.character(ci_diffs$contrast)," - "))))
          split2a <- data.frame(t(do.call("cbind", strsplit(as.character(split1$X1),","))))
          colnames(split2a) <- c('x1','g1')
          split2b <- data.frame(t(do.call("cbind", strsplit(as.character(split1$X2),","))))
          colnames(split2b) <- c('x2','g2')
          splits <- data.table(split2a, split2b)
          # splits[, x1:=as.character(x1)]
          # splits[, x2:=as.character(x2)]
          # splits[, g1:=as.character(g1)]
          # splits[, g2:=as.character(g2)]
          if(interaction.group==TRUE){
            inc <- c(inc, which(splits[,g1]==splits[,g2]))
          }
          if(interaction.treatment==TRUE){
            inc.x <- which(splits[,x1]==splits[,x2])
            t.x <- factor(splits[inc.x, x1], levels(dt[, get(x)]))
            inc <- c(inc, inc.x[order(t.x)])
          }
          ci_diffs <- ci_diffs[inc,]
        }
        tables$contrasts <- ci_diffs
        ci_diffs <- data.table(ci_diffs, g='dummy')
      }
      if(grouping==TRUE & add_interaction==FALSE){
        if(contrasts.method=='revpairwise'){
          p_levels <- n_levels*(n_levels-1)/2
          p_groups <- n_groups*(n_groups-1)/2
        }else{
          p_levels <- n_levels-1
          p_groups <- n_groups-1
        }
        ci_diffs.x <- data.table(summary(contrast(lsm, method=contrasts.method, by=g), adjust=ci.adjust, level=conf.contrast, infer=c(TRUE,TRUE)))[1:p_levels]
        setnames(ci_diffs.x, old=c(g), new='by')
        ci_diffs.g <- data.table(summary(contrast(lsm, method=contrasts.method, by=x), adjust=ci.adjust, level=conf.contrast, infer=c(TRUE,TRUE)))[1:p_groups]
        setnames(ci_diffs.g, old=c(x), new='by')
        ci_diffs <- data.table(NULL)
        if(interaction.treatment==TRUE){ci_diffs <- rbind(ci_diffs, ci_diffs.x)}
        if(interaction.group==TRUE){ci_diffs <- rbind(ci_diffs, ci_diffs.g)}
        tables$contrasts <- copy(ci_diffs)
        setnames(ci_diffs, old=c('by'), new='g')
        # ci_diffs.x[, g:='x']
        # ci_diffs.g[, g:='g']
      }
      ci_diffs <- ci_diffs[, .SD, .SDcols=c('contrast','g','estimate','lower.CL','upper.CL')]
    }
    if(fit.model=='bayes'){
      conf.tail <- conf.contrast + (1-conf.contrast)/2
      res <- summary(as.mcmc(contrast(post.lsm, method=contrasts.method)), quantiles = c(0.5, (1-conf.tail), conf.tail))$quantiles*mad
      ci_diffs <- data.table(x=row.names(res),res)
      ci_diffs[, x:=factor(substr(x,10,nchar(x)))]
    }
    
    setnames(ci_diffs, old=colnames(ci_diffs), new=c(x, g, y,'lower','upper'))
    return(list(fit=fit, ci_means=ci_means, ci_diffs=ci_diffs, tables=tables, codes=code.fit))
  }
  
  Hdotplot <- function(
    # function for Harrel or Horizontal dot plot after Harrel's Hmisc
    x,
    y,
    g='None',
    df, # data frame or table
    fit.model='lm', # lm, glm
    error='Normal', # normal, lognormal, logistic, poisson
    add_interaction=FALSE,
    interaction.group=FALSE,
    interaction.treatment=TRUE,
    mean_intervals.method='lm', # model for CI of mean
    conf.mean=0.95, # confidence level for CI of mean
    contrasts.method='coefficients', # which contrasts to show
    conf.contrast=0.95,
    adjust=FALSE,
    show.contrasts=TRUE,
    show.treatments=TRUE,
    display.treatment='box',
    short=FALSE,
    show.mean=TRUE,
    show.dots=TRUE,
    horizontal=TRUE,
    color_palette='Greys',
    jtheme='minimal'
  ){
    # subset data
    if(g == 'None'){
      xcols <- x
      grouping <- FALSE
    }else{
      xcols <- c(x,g)
      grouping <- TRUE
    }
    df <- data.table(df)
    dt <- df[, .SD, .SDcols=c(xcols, y)]
    dt <- na.omit(dt) # has to be after groups read in
    
    # add empty grouping variable column if grouping == FALSE to make subsequent code easier
    if(grouping == FALSE){
      g <- 'dummy_g'
      dt[, (g):='dummy']
    }
    
    # abbreviate levels if TRUE
    if(short==TRUE){
      dt[, (x):=abbreviate(get(x))]
      dt[, (g):=abbreviate(get(g))]
    }
    x_order <- dt[,.(i=min(.I)),by=get(x)][, get]
    dt[, (x):=factor(get(x), x_order)]
    g_order <- dt[,.(i=min(.I)),by=get(g)][, get]
    dt[, (g):=factor(get(g), g_order)]
    
    ybar <- mean(range(dt[, get(y)])) # needed to shift contrasts for double-Y plot
    
    res <- fit_model(x, y, g, dt, fit.model, error, add_interaction, interaction.group, interaction.treatment, mean_intervals.method, conf.mean, contrasts.method, conf.contrast, adjust)
    
    ci_means <- res$ci_means
    ci_diffs <- res$ci_diffs
    tables <- res$tables
    codes <- res$codes
    
    # add ybar to y
    c_levels <- as.character(ci_diffs[, get(x)])
    ci_diffs[, (x):=factor(get(x), levels=c_levels)]
    ci_diffs[, (y):=get(y) + ybar] # will be corrected by sec.axis in ggplot
    ci_diffs[, lower:=lower + ybar] # will be corrected by sec.axis in ggplot
    ci_diffs[, upper:=upper + ybar] # will be corrected by sec.axis in ggplot
    
    #     contrast intervals
    x_levels <- levels(dt[,get(x)]) # levels for means plot
    g_levels <- levels(dt[,get(g)])
    n_levels <- length(x_levels)
    n_groups <- length(g_levels)
    
    # make a dummy x for categorical variables for means
    n_contrasts <- length(c_levels)
    width <- 0.8
    offset <- mean(1:n_groups/n_groups)
    contraction <- 1/ceiling(n_groups/2)
    # x.d is the dummy variable for plotting. The levels of x.d are given integer values and the 
    # levels of g are clustered at each integer
    dt[, x.d:=as.numeric(factor(get(x)))]
    dt[, x.d:=(x.d + width*(as.numeric(factor(get(g)))/n_groups - offset))]
    ci_means[, x.d:=as.numeric(factor(get(x)))]
    ci_means[, x.d:=(x.d + width*(as.numeric(factor(get(g)))/n_groups - offset))]
    contrast_breaks <- seq(from=(n_levels+1), to=(n_levels+1 + n_contrasts*contraction - contraction), by=contraction)
    ci_diffs[, x.d:= contrast_breaks]
    
    dt <- rbind(data.table(estimate='means',dt),
                data.table(estimate='contrasts',ci_diffs[,.SD,.SDcols=c(x, g, y, 'x.d')]))
    ci <- rbind(data.table(estimate='means',ci_means),
                data.table(estimate='contrasts',ci_diffs))
    # create dummy y and g column for plotting
    dt[, y.d:=get(y)]
    ci[, y.d:=get(y)]
    dt[, g.d:=get(g)]
    ci[, g.d:=get(g)]
    # dt[, x.fac:=x]
    # ci[, x.fac:=x]
    
    # set x-axis breaks and bounds
    # breaks = 1:hi, label=levels(dt[,x.fac][lo:hi]), limits = c((lo-0.5), (hi+0.5)),
    if(show.treatments == FALSE){
      lo <- NA
      hi <- NA
      breaks <- NULL
      break_labels <- NULL
    }else{
      lo <- min(dt[, x.d])
      hi <- max(dt[estimate=='means', x.d])
      breaks <- 1:n_levels
      break_labels <- x_levels
    }
    if(show.contrasts == TRUE){
      if(is.na(lo)){
        lo <- n_levels+1
      }
      hi <- max(dt[, x.d])
      breaks <- c(breaks, contrast_breaks)
      break_labels <-c(break_labels, c_levels)
    }
    guide.boxplot <- FALSE
    guide.dots <- FALSE
    if(grouping==TRUE){
      #guide.boxplot <- ifelse(display.treatment=='box',TRUE,FALSE)
      guide.boxplot <- TRUE
      guide.dots <- ifelse(guide.boxplot==TRUE,FALSE,TRUE)
    }
    
    # x transformed to x.d and categorical x put into x.fac above 
    gg <- ggplot(data=dt, aes(x=x.d, y=y.d))
    
    # plot dots/mean/boxplot
    if(show.treatments == TRUE){
      #        for(i in 1:n_groups){
      if(display.treatment=='box'){ # plot before dots
        if(show.dots==TRUE){outlier_color <- NA}else{outlier_color <- NULL}
        gg <- gg + geom_boxplot(data=dt[estimate=='means',], aes(group=x.d, fill=g.d), outlier.colour = outlier_color, show.legend = guide.boxplot)
        if(guide.boxplot==TRUE){
          gg <- gg + guides(fill = guide_legend(g))}
        else{
          gg <- gg + guides(fill=FALSE)
        }
      }
      if(show.dots==TRUE){
        gg <- gg + geom_jitter(data=dt[estimate=='means',], aes(x=x.d,y=y.d), width = (0.8*0.5)/n_groups/2, height = 0.0, show.legend = guide.dots, color='black', alpha=0.5)
        if(guide.dots==TRUE){gg <- gg + guides(color = guide_legend(g))}else{
          gg <- gg+ guides(color=FALSE)
        }
      }
      if(display.treatment=='ci'){
        gg <- gg + geom_linerange(data=ci[estimate=='means',], aes(ymin = lower, ymax = upper, color=g.d), size=2)
        if(guide.boxplot==TRUE){gg <- gg + guides(color = guide_legend(g))}else{
          gg <- gg + guides(color=FALSE)
        }
      }
      if(show.mean==TRUE){
        dot_color <- ifelse(color_palette=='Greys','red','black')
        gg <- gg + geom_point(data=ci[estimate=='means',], aes(x=x.d,y=y.d), size=3, color='white')
        gg <- gg + geom_point(data=ci[estimate=='means',], aes(x=x.d,y=y.d), size=2, color=dot_color)
      }
    }
    
    # plot contrasts
    if(show.contrasts == TRUE){
      # draw line at y=0 first
      gg <- gg + geom_segment(x=n_levels+0.6, y=0.0 + ybar, xend=hi+0.4, yend=0.0 + ybar, size=0.5, color='darkgrey', linetype='dashed')
      gg <- gg + geom_linerange(data=ci[estimate=='contrasts',], aes(ymin = lower, ymax = upper), color='black', size=2)
      gg <- gg + geom_point(data=ci[estimate=='contrasts',], aes(x=x.d,y=y.d), size=3, color='white')
      gg <- gg + geom_point(data=ci[estimate=='contrasts',], aes(x=x.d,y=y.d), size=2, color='black')
      gg <- gg + scale_y_continuous(sec.axis = sec_axis(~.-ybar, name = "Difference"))
      if(show.treatments == TRUE){
        gg <- gg + geom_vline(xintercept=n_levels+0.5, size=1, color='darkgrey')
      }
    }
    
    gg <- gg + labs(x=x, y=y)
    
    # build X axes
    pos_labels <- c((n_levels+1)/2, median(contrast_breaks))
    contrast_txt <- ifelse(contrasts.method=='coefficients', 'Coefficient', 'Contrast')
    gg <- gg + scale_x_continuous(
      breaks = breaks, label=break_labels, 
      # limits = c((lo-contraction/2), (hi+contraction/2)),
      sec.axis = sec_axis(~.+0, breaks=pos_labels, labels=c(x, contrast_txt)))
    
    # set colors
    if(color_palette != 'ggplot'){
      gg <- gg + scale_color_brewer(palette = color_palette)
      gg <- gg + scale_fill_brewer(palette = color_palette)
    }
    
    # set theme
    if(jtheme=='grey'){gg <- gg + theme_grey(base_size = 18)}
    if(jtheme=='gray'){gg <- gg + theme_gray(base_size = 18)}
    if(jtheme=='bw'){gg <- gg + theme_bw(base_size = 18)}
    if(jtheme=='classic'){gg <- gg + theme_classic(base_size = 18)}
    if(jtheme=='minimal'){gg <- gg + theme_minimal(base_size = 18)}
    
    if(horizontal==TRUE){
      gg <- gg + coord_flip()
      gg <- gg + theme(axis.title.y = element_blank(),
                       axis.text.y.right= element_text(angle = -90, hjust = 0.5),
                       legend.position = 'bottom')
    }else{
      gg <- gg + theme(axis.title.x = element_blank())
    }
    
    return(list(gg=gg, tables=tables, codes=codes))
  }
  
  plotInput <- function(df){
    # model
    fit.model <- input$model
    error <- input$error
    x <- input$treatment
    y <- input$response
    g <- input$group
    
    #set inputs to non-shiny variables
    # confidence limits for contrasts and means
    conf <- c(0.99, 0.95, 0.9)
    conf.contrast <- conf[as.numeric(as.character(input$conf.contrast))]
    conf.mean <- conf[as.numeric(as.character(input$conf.mean))]
    
    # contrasts
    # method for computation of treatment CI
    # control or pairwise contrasts
    contrast_array <- c('coefficients','trt.vs.ctrl1', 'revpairwise') # c("Control", "Pairwise") in menu 
    contrasts.method <- contrast_array[as.numeric(as.character(input$contrasts.method))]
    # adjust for multiple tests
    adjust <- ifelse(input$adjust==TRUE, TRUE, FALSE)
    # interaction?
    if(is.null(input$interaction)){
      add_interaction <- FALSE
    }else{
      add_interaction <- ifelse(input$interaction==TRUE, TRUE, FALSE)
    }
    interaction.group <- input$interaction.group
    interaction.treatment <- input$interaction.treatment
    
    # treatments
    input_array <- c('box','ci')
    display.treatment <- input_array[as.numeric(as.character(input$display.treatment))]
    # method for computation of treatment CI
    interval_array <- c('raw','lm','boot','bayes')
    mean_intervals.method <- interval_array[as.numeric(as.character(input$mean_intervals.method))]
#    mean_intervals.method <- input$mean_intervals.method
    
    # plot
    color_array <- c("ggplot", "Greys", "Blues", "Accent", "Dark2", "Set1", "Set2", "Set3")
    color_palette <- color_array[as.numeric(as.character(input$colors))]
    theme_array <- c("gray", "bw", "classic", "minimal")
    jtheme <- theme_array[as.numeric(as.character(input$theme))]
    show.treatments <- ifelse(input$hide.treatments==FALSE, TRUE, FALSE)
    show.contrasts <- ifelse(input$hide.contrasts==FALSE, TRUE, FALSE)
    show.mean <- ifelse(input$mean==TRUE, TRUE, FALSE)
    show.dots <- ifelse(input$dots==TRUE, TRUE, FALSE)
    horizontal <- ifelse(input$horizontal==TRUE, TRUE, FALSE)
    
    if(input$short==FALSE){short <- FALSE}else{short <- TRUE}
    
    res <- Hdotplot(x, y, g, df, fit.model, error, add_interaction, interaction.group, interaction.treatment, mean_intervals.method, conf.mean, contrasts.method, conf.contrast, adjust, show.contrasts, show.treatments, display.treatment, short, show.mean, show.dots, horizontal, color_palette, jtheme)
    
    plots$p1 <- res$gg
    return(res)
  }
  
  # output contrast interval method
  output$interval_text <- renderText({
    df <- dataInput()
    if (is.null(df)) return(NULL)
    #    if(input$treatment != ' ' & input$response != ' '){
    if(input$model=='bayes'){ #bootstrap or bayes
      adjust_text <- 'no'
    }else{
      if(input$adjust==FALSE){adjust_text <- 'none'}else{
        adjust_text <- ifelse(input$contrasts.method==2, 'Dunnet t approximation','Tukey HSD')
      }
    }
    conf <- c(0.99, 0.95, 0.9)
    conf.contrast <- as.integer(conf[as.numeric(as.character(input$conf.contrast))]*100)
    out_text <- paste('contrasts with ',conf.contrast,'% CI using adjustment: ',adjust_text, sep='')
    out_text
    #    }
  })
  
  output$formulaCaption <- renderText({
    df <- dataInput()
    if (is.null(df)) return(NULL)
    "The Model"
  })
  
  output$modelFormula <- renderPrint({
    df <- dataInput()
    if (is.null(df)) return(NULL)
    tables <- plotInput(df)$tables
    print(tables$form_str, showEnv=FALSE)
  })
  
  output$contrastsCaption <- renderText({
    df <- dataInput()
    if (is.null(df)) return(NULL)
    "Model Contrasts"
  })
  
  output$modelContrasts <- renderPrint({
    df <- dataInput()
    if (is.null(df)) return(NULL)
    tables <- plotInput(df)$tables
    
    if(input$notPretty == TRUE){
      print(tables$contrasts)
    }else{ # pretty
      print(round_df(tables$contrasts, 3), row.names=FALSE)
    }
  })
  
  output$coefCaption <- renderText({
    df <- dataInput()
    if (is.null(df)) return(NULL)
    "Model Coefficients"
  })
  
  output$modelCoefficients <- renderPrint({
    df <- dataInput()
    if (is.null(df)) return(NULL)
    tables <- plotInput(df)$tables
    if(input$notPretty == TRUE){
      print(tables$coeffs)
    }else{ # pretty
      coef_dt <- data.table(Coeffcient=row.names(tables$coeffs), tables$coeffs)
      print(round_df(coef_dt, 3), row.names=FALSE)
    }
  })
  
  output$sumCaption <- renderText({
    df <- dataInput()
    if (is.null(df)) return(NULL)
    "Model Summary"
  })
  
  output$modelSummary <- renderPrint({
    df <- dataInput()
    if (is.null(df)) return(NULL)
    tables <- plotInput(df)$tables
    if(input$notPretty == TRUE){
      print(tables$summary, row.names=FALSE)
    }else{ # pretty
      print(round_df(tables$summary, 3), row.names=FALSE)
    }
  })
  
  output$meansCaption <- renderText({
    df <- dataInput()
    if (is.null(df)) return(NULL)
    "Model Means"
  })
  
  output$modelMeans <- renderPrint({
    df <- dataInput()
    if (is.null(df)) return(NULL)
    tables <- plotInput(df)$tables
    if(input$notPretty == TRUE){
      print(tables$means)
    }else{ # pretty
      print(round_df(tables$means, 3), row.names=FALSE)
    }
  })
  
  output$anovaCaption <- renderText({
    df <- dataInput()
    if (is.null(df)) return(NULL)
    "Model ANOVA (type I, II, III)"
  })
  
  output$modelAnova1 <- renderPrint({
    df <- dataInput()
    if (is.null(df)) return(NULL)
    tables <- plotInput(df)$tables
    tables$anova.1
  })
  
  output$modelAnova2 <- renderPrint({
    df <- dataInput()
    if (is.null(df)) return(NULL)
    tables <- plotInput(df)$tables
    tables$anova.2
  })
  
  output$modelAnova3 <- renderPrint({
    df <- dataInput()
    if (is.null(df)) return(NULL)
    tables <- plotInput(df)$tables
    tables$anova.3
  })
  
  output$modelCode <- renderPrint({
    df <- dataInput()
    if (is.null(df)) return(NULL)
    codes <- plotInput(df)$codes
    str1 <- 'library(ggplot2)'
    str2 <- 'library(lsmeans)'
    str3 <- 'library(broom)'
    str4 <- 'library(data.table)'
    h <- paste(str1, str2, str3, str4, sep = '<br/>')
    h <- c(h, '<br/>', paste(codes$data, collapse='<br/>'))
    h <- c(h, '<br/>', paste(codes$fit, collapse='<br/>'))
    HTML(h)
  })
  
  # download
  # output$downloadPlot <- downloadHandler(
  #   filename = 'temp.png',
  #   content = function(file) {
  #     device <- function(..., width, height) grDevices::png(..., width = width, height = height, res = 300, units = "in")
  #     ggsave(file, plot = plotInput(), device = device)
  #   }
  # )
  
  # plot to the model panel
  output$hDotPlot.model <- renderPlot({
    df <-dataInput()
    if (is.null(df)) return(NULL)
    if(input$treatment != ' ' & 
       is.numeric(df[[input$response]])){
      print(plotInput(df)$gg)
    }
  })  
  
  # plot to the plot panel
  output$hDotPlot.plot <- renderPlot({
    df <-dataInput()
    if (is.null(df)) return(NULL)
    if(input$treatment != ' ' & 
       is.numeric(df[[input$response]])){
      print(plotInput(df)$gg)
    }
  })  
  
  output$downloadPlot = downloadHandler(
    filename = function() {"Hdotplot.pdf"},
    content = function(file) {
      pdf(file, width=input$width, height=input$height, onefile = TRUE)
      grid.arrange(plots$p1) 
      dev.off()
    }
  )
  
}


# Run the application 
shinyApp(ui = ui, server = server)

