# "Harrell" or "horizontal" dot plot - defaults to ploting treatment contrasts
# in upper panel and treatment boxplots in lower planel
# Jeffrey A. Walker
# November 24, 2017

library(shiny)
library(gridExtra) # needed for download
library(ggplot2)
library(broom)
library(lsmeans)
library(data.table)
#library(Hmisc)
#library(MCMCpack)
#library(coda)


# Define UI for application that draws a histogram
ui <- fluidPage(
  
  # sidebarLayout(
  # App title ----
  titlePanel("Hdotplot"),
  
  # Sidebar panel for inputs ----
  sidebarPanel(
    conditionalPanel(condition = "input.tabs=='Model'",
                     # Input file
                     fileInput("FileInput", "Choose file"),
                     
                     h3("Model"),
                     # reactive Input for treatment
                     uiOutput("treatment"),
                     # reactive Input for response
                     uiOutput("response"),
                     # reactive Input for grouping
                     uiOutput("group"),
                     
                     checkboxInput("interaction", "Add interaction", FALSE),
                     
                     # contrast method
                     selectInput("contrasts.method", h3("Contrasts"), 
                                 choices = list("Coefficients" = 1,"vs. Control" = 2, "Pairwise" = 3), selected = 2),
                     # Input: Checkbox for multiple tests
                     checkboxInput("adjust", "Adjust for multiple tests", FALSE),
                     # Input: Confidence level
                     selectInput("conf.contrast", h5("Confidence level"), 
                                 choices = list("99%" = 1, "95%" = 2, "90%" = 3), selected = 2),
                     # Input: Contrasts Confidence Interval Model
                     selectInput("intervals.contrast", h5("Contrasts CI model"), 
                                 choices = list("lm" = 1), selected = 1),
                     
                     selectInput("display.treatment", h3("Treatments"), 
                                 choices = list("Box plot" = 1, "Confidence Interval" = 2), selected = 1),
                     
                     # Input: Confidence level
                     selectInput("conf.mean", h5("Confidence level"), 
                                 choices = list("99%" = 1, "95%" = 2, "90%" = 3), selected = 2),
                     
                     # Input: Confidence Interval Model
                     # selectInput("intervals.mean", h5("Treatment CI model"), 
                     #       choices = list("raw" = 1, "lm" = 2, "bootstrap" = 3, "Bayesian" = 4), selected = 1),
                     selectInput("intervals.mean", h5("Treatment CI model"), 
                                 choices = list("raw" = 1, "lm" = 2, "bootstrap" = 3), selected = 1)
                     
                     
    ),
    
    conditionalPanel(condition = "input.tabs=='Plot'",
                     h3("Plot"),
                     # Input: colors
                     selectInput("colors", h5("Plot Colors"), 
                                 choices = list("ggplot" = 1, "Greys" = 2, "Blues" = 3,
                                                "Accent"=4, "Dark2"=5, "Set1"=6, "Set2"=7,
                                                "Set3"=8), selected = 2),
                     # Input: theme
                     selectInput("theme", h5("Plot Theme"), 
                                 choices = list("gray" = 1, "bw" = 2, "classic" = 3, 
                                                "minimal" = 4), selected = 4),
                     checkboxInput("hide.contrasts", "Hide contrasts", FALSE),
                     checkboxInput("hide.treatments", "Hide treatments", FALSE),
                     # Input: flip axes ----
                     checkboxInput("flip", "Horizontal bars", TRUE),
                     
                     # Input: abbreviate factor levels
                     checkboxInput("short", "Abbreviate factor levels", FALSE),
                     
                     # Input: Checkbox for dots ----
                     checkboxInput("dots", "Show dots", TRUE),
                     # Input: Checkbox for Mean
                     checkboxInput("mean", "Show Mean", TRUE)
                     
                     
    ),
    
    conditionalPanel(condition = "input.tabs=='Save'",
                     h3("Download"),
                     numericInput("width", "Width (inches)", 7, min = 2, max = 10, step = 0.25),
                     numericInput("height", "Height (inches)", 5, min = 2, max = 10, step = 0.25)
                     
    )
    
  ),
  
  # Main panel for displaying outputs ----
  mainPanel(
    
    tabsetPanel(type = "tabs",
                tabPanel("Model",
                         # Output: CI level and adjustment for contrasts
                         textOutput("interval_text"),
                         
                         # Output: Plot
                         plotOutput("hDotPlot.model", width = "100%", height = "600px")
                ),
                tabPanel("Plot",
                         # Output: Plot
                         plotOutput("hDotPlot.plot", width = "100%", height = "600px")
                ),
                tabPanel("Table",
                         textOutput("formulaCaption"),
                         verbatimTextOutput("modelFormula"),
                         textOutput("contrastsCaption"),
                         verbatimTextOutput("modelContrasts"),
                         textOutput("sumCaption"),
                         verbatimTextOutput("modelSummary"),
                         textOutput("coefCaption"),
                         verbatimTextOutput("modelCoefficients"),
                         textOutput("meansCaption"),
                         verbatimTextOutput("modelMeans"),
                         textOutput("anovaCaption"),
                         verbatimTextOutput("modelAnova")
                ),
                tabPanel("Code",
                         htmlOutput("modelCode")
                ),
                tabPanel("Save",
                         
                         # print the plot
                         downloadButton(outputId = "downloadPlot", label = "Download the plot")
                ),
                id = 'tabs'
    )
    
  )
  #  )
)


# Define server logic to plot various variables against mpg ----
server <- function(input, output) {
  # global variable for downloading plot
  files <- reactiveValues(f1=FALSE)
  plots <- reactiveValues(p1=NULL)
  tables <- reactiveValues(form_str=NULL, fit=NULL, coeffs=NULL, summary=NULL, means=NULL, diffs=NULL)
#  code <- reactiveValues(fit=NULL)
  
  # populate Treatment input
  output$treatment <- renderUI({
    df <-datasetInput()
    if (is.null(df)) return(NULL)
    items=c(' ', names(df))
    #    names(items)=items
    selectInput("treatment", "Treatment",items)
  })
  
  # populate Response input
  output$response <- renderUI({
    df <-datasetInput()
    if (is.null(df)) return(NULL)
    items=c(' ', names(df))
    #    names(items)=items
    selectInput("response", "Response",items)
  })
  
  # populate Group input
  output$group <- renderUI({
    df <-datasetInput()
    if (is.null(df)) return(NULL)
    items=c(' ', names(df))
    #    names(items)=items
    selectInput("group", "Grouping",items)
  })
  
  
  #  the function to plot the data
  # read data file
  datasetInput <- reactive({
    infile <- input$FileInput # opens file browser
    if(is.null(infile))
      return(NULL)
    df <- fread(infile$datapath, stringsAsFactors = TRUE)
    return(df)
  })
  
  form <- function(y, xcols){
    form_str <- paste(y, ' ~ ', paste(xcols, collapse=' + '), sep='')
    # if(input$interaction==TRUE & length(xcols)==2){
    #   form_str <- paste(form_str, paste(xcols[1],':',xcols[2], sep=''), sep = ' + ')
    # }
    return(form_str)
  }
  
  fit_model <- function(
    dt, # data table with columns y, x, and g
    xcols, # name of x and g columns
    grouping=FALSE,
    add_interaction=FALSE,
    intervals.mean='lm', # model for CI of mean
    conf.mean=0.95, # confidence level for CI of mean
    intervals.contrast='lm', # which model to fit
    contrasts.method='coefficients', # which contrasts to show
    conf.contrast=0.95
  ){
    xcol_names <- xcols
    xcols <- 'x'
    if(grouping==TRUE){xcols <- c(xcols,'g')}
    
    if(add_interaction==TRUE){
      form_str <- paste('y ~ ', paste(xcols, collapse='*'), sep='')
#      code$fit <- "paste('y ~ ', paste(xcols, collapse='*'), sep='')"
    }else{
      form_str <- paste('y ~ ', paste(xcols, collapse=' + '), sep='')
#      code$fit <- "paste('y ~ ', paste(xcols, collapse='*'), sep='')"
    }
    form <- formula(form_str)
    fit <- lm(form, data=dt)
    lsm <- lsmeans(fit, specs=xcols)
    
    # save global
    tables$fit <- fit
    tables$form_str <- form_str
    tables$coeffs <- coefficients(summary(fit))
    tables$summary <-glance(fit)
    
    # code
    # code$fit <- list(code$fit, "form <- formula(form_str)", 
    #                  "fit <- lm(form, data=dt)",
    #                  "lsm <- lsmeans(fit, specs=xcols)")
    
    #     Bayes model
    #  mad <- median(abs(dt[,y] - mean(dt[,y])))
    #  #dt[,y.mad:=y/mad]
    #  y.mad <- dt[,y]/mad
    #  fit.mcmc <- MCMCregress(y.mad ~ x, data=dt, b0 = 0, B0 = 0.1, c0=2, d0=0.11)
    #  post.lsm <- lsmeans(fit.mcmc, specs='x')
    # # dt <- dt[, .SD, .SDcols=c('x','y')] #drop y.mad because need to bind ci later
    
    # means intervals
    if(intervals.mean=='lm'){
      tables$means <- confint(lsm, level=conf.mean)
      ci_means <- data.table(tables$means) # mean intervals not adjusted
      ci_means <- ci_means[, .SD, .SDcols=c(xcols,'lsmean','lower.CL','upper.CL')]
    }
    if(intervals.mean=='raw'){
      conf.tail <- conf.mean + (1-conf.mean)/2
      tables$means <- dt[, .(
        mean=mean(y),
        sem=sd(y)/sqrt(.N),
        lower=mean(y)-sd(y)/sqrt(.N)*qt(conf.tail,(.N-1)),
        upper=mean(y)+sd(y)/sqrt(.N)*qt(conf.tail,(.N-1))),
        by=xcols]
      ci_means <- tables$means[, .SD, .SDcols=c(xcols,'mean', 'lower','upper')]
    }
    if(intervals.mean=='boot'){
      dt_boot <- data.table(dt[, smean.cl.boot(y,conf.int=conf.mean), by=xcols])
      dt_boot[, tile:=c('a','lower','upper')]
      form <- formula(paste(paste(xcols,collapse='+'),'tile',sep='~'))
      ci_means <- dcast(dt_boot, form, value.var='V1') #**** change x+g to formula
    }
    if(intervals.mean=='bayes'){
      conf.tail <- conf.mean + (1-conf.mean)/2
      res <- summary(as.mcmc(post.lsm), quantiles = c(0.5, (1-conf.tail), conf.tail))$quantiles*mad
      ci_means <- data.table(x=row.names(res),res)
      ci_means[, x:=factor(substr(x,3,nchar(x)))]
    }
    if(grouping==FALSE){
      ci_means[, g:='']
      setnames(ci_means, old=colnames(ci_means), new=c('x','y','lower','upper','g'))
      ci_means <- ci_means[,.SD, .SDcols=c('x','g','y','lower','upper')]
    }else{
      setnames(ci_means, old=colnames(ci_means), new=c(xcols,'y','lower','upper'))
    }
    
    #     contrast intervals
    m_levels <- levels(dt[,x]) # levels for means plot
    g_levels <- levels(dt[,g])
    n_levels <- length(m_levels)
    n_groups <- length(g_levels)
    
    if(contrasts.method=='coefficients'){
      ci_diffs <- coefficients(summary(fit))[-1,]
      x_names <- c(levels(dt$x)[-1],levels(dt$g)[-1])
      if(add_interaction==TRUE){
        temp <- expand.grid(levels(dt$x)[-1],levels(dt$g)[-1])
        x_names <- c(x_names, paste(temp$Var1, temp$Var2, sep=':'))
      }
      ci_diffs <- data.table(contrast=x_names, g=NA, ci_diffs, confint(fit, level=conf.contrast)[-1,])
      temp <- confint(fit, level=conf.contrast)[-1,]
      setnames(ci_diffs, old=colnames(ci_diffs), new = c('contrast', 'g', 'estimate', 'Std. Error', 't value', 'Pr(>|t|)', 'lower', 'upper'))
      tables$contrasts <- ci_diffs
      ci_diffs <- ci_diffs[, .SD, .SDcols=c('contrast','g','estimate','lower','upper')]
      ci_diffs[, contrast:=factor(contrast, levels=x_names)]
    }
    if(intervals.contrast=='lm' & contrasts.method!='coefficients'){
      ci.adjust <- 'none'
      if(adjust==TRUE){
        ci.adjust <- ifelse(contrasts.method=='trt.vs.ctrl1', 'dunnettx','tukey')
      }
      if(grouping==FALSE | add_interaction==TRUE){
        #        ci_diffs <- data.table(confint(contrast(lsm, method=contrasts.method), adjust=ci.adjust, level=conf.contrast))
        ci_diffs <- data.table(summary(contrast(lsm, method=contrasts.method), adjust=ci.adjust, level=conf.contrast, infer=c(TRUE,TRUE)))
        ci_diffs[, g:=NA]
        if(grouping==TRUE & contrasts.method=='revpairwise'){ # subset into pairwise within each group
          # another method
          # fread(paste(as.character(ci_diffs$contras), collapse='\n'), sep='-')
          split1 <- data.frame(t(do.call("cbind", strsplit(as.character(ci_diffs$contrast)," - "))))
          split2a <- data.frame(t(do.call("cbind", strsplit(as.character(split1$X1),","))))
          colnames(split2a) <- c('x1','g1')
          split2b <- data.frame(t(do.call("cbind", strsplit(as.character(split1$X2),","))))
          colnames(split2b) <- c('x2','g2')
          splits <- data.table(split2a, split2b)
          inc <- which(splits[,g1]==splits[,g2])
          ci_diffs <- ci_diffs[inc,]
        }
        tables$contrasts <- ci_diffs
      }
      if(grouping==TRUE & add_interaction==FALSE){
        if(contrasts.method=='revpairwise'){
          p_levels <- n_levels*(n_levels-1)/2
          p_groups <- n_groups*(n_groups-1)/2
        }else{
          p_levels <- n_levels-1
          p_groups <- n_groups-1
        }
        # ci_diffs.x <- data.table(confint(contrast(lsm, method=contrasts.method, by='g'), adjust='none', level=conf.contrast))[1:p_levels]
        # ci_diffs.x[, g:=xcol_names[1]]
        # ci_diffs.g <- data.table(confint(contrast(lsm, method=contrasts.method, by='x'), adjust='none', level=conf.contrast))[1:p_groups]
        # setnames(ci_diffs.g, old=c('x'), new='g')
        
        ci_diffs.x <- data.table(summary(contrast(lsm, method=contrasts.method, by='g'), adjust=ci.adjust, level=conf.contrast, infer=c(TRUE,TRUE)))[1:p_levels]
        ci_diffs.x[, g:=xcol_names[1]]
        ci_diffs.g <- data.table(summary(contrast(lsm, method=contrasts.method, by='x'), adjust=ci.adjust, level=conf.contrast, infer=c(TRUE,TRUE)))[1:p_groups]
        setnames(ci_diffs.g, old=c('x'), new='g')
        ci_diffs.g[, g:=xcol_names[2]]
        ci_diffs <- rbind(ci_diffs.x, ci_diffs.g)
        tables$contrasts <- ci_diffs
      }
      ci_diffs <- ci_diffs[, .SD, .SDcols=c('contrast','g','estimate','lower.CL','upper.CL')]
    }
    if(intervals.contrast=='bayes'){
      conf.tail <- conf.contrast + (1-conf.contrast)/2
      res <- summary(as.mcmc(contrast(post.lsm, method=contrasts.method)), quantiles = c(0.5, (1-conf.tail), conf.tail))$quantiles*mad
      ci_diffs <- data.table(x=row.names(res),res)
      ci_diffs[, x:=factor(substr(x,10,nchar(x)))]
    }
    
    setnames(ci_diffs, old=colnames(ci_diffs), new=c('x','g','y','lower','upper'))
    return(list(fit=fit, ci_means=ci_means, ci_diffs=ci_diffs))
  }
  
  plotInput <- function(){
    df <-datasetInput()
    if (is.null(df)) return(NULL)
    
    dt <- data.table(x = factor(df[[input$treatment]]), g = '', y = df[[input$response]])
    
    if(is.numeric(dt[, y])){
      #set inputs to non-shiny variables
      # confidence limits for contrasts and means
      conf <- c(0.99, 0.95, 0.9)
      conf.contrast <- conf[as.numeric(as.character(input$conf.contrast))]
      conf.mean <- conf[as.numeric(as.character(input$conf.mean))]
      
      # contrasts
      # method for computation of treatment CI
      interval_array <- c('lm','boot','bayes')
      intervals.contrast <- interval_array[as.numeric(as.character(input$intervals.contrast))]
      # control or pairwise contrasts
      contrast_array <- c('coefficients','trt.vs.ctrl1', 'revpairwise') # c("Control", "Pairwise") in menu 
      contrasts.method <- contrast_array[as.numeric(as.character(input$contrasts.method))]
      # adjust for multiple tests
      adjust <- ifelse(input$adjust==TRUE, TRUE, FALSE)
      add_interaction <- ifelse(input$interaction==TRUE, TRUE, FALSE)
      
      # treatments
      input_array <- c('box','ci')
      display.treatment <- input_array[as.numeric(as.character(input$display.treatment))]
      # method for computation of treatment CI
      interval_array <- c('raw','lm','boot','bayes')
      intervals.mean <- interval_array[as.numeric(as.character(input$intervals.mean))]
      
      # grouping
      if(input$group==' '){grouping <- FALSE}else{grouping <- TRUE}
      
      # plot
      color_array <- c("ggplot", "Greys", "Blues", "Accent", "Dark2", "Set1", "Set2", "Set3")
      color_palette <- color_array[as.numeric(as.character(input$colors))]
      theme_array <- c("gray", "bw", "classic", "minimal")
      jtheme <- theme_array[as.numeric(as.character(input$theme))]
      show.treatments <- ifelse(input$hide.treatments==FALSE, TRUE, FALSE)
      show.contrasts <- ifelse(input$hide.contrasts==FALSE, TRUE, FALSE)
      show.mean <- ifelse(input$mean==TRUE, TRUE, FALSE)
      
      if(input$short==FALSE){short <- FALSE}else{short <- TRUE}
      
      xcols <- 'x'
      if(grouping == TRUE){
        dt[,g:=factor(df[[input$group]])]
        xcols <- c('x','g')
      }
      dt <- na.omit(dt)
      if(short==TRUE){
        dt[,x:=abbreviate(x)]
        dt[,g:=abbreviate(g)]
      }
      dt[,x:=factor(x, dt[,.(i=min(.I)),by=x][,x])]
      dt[,g:=factor(g, dt[,.(i=min(.I)),by=g][,g])]
      ybar <- mean(dt[,y]) # needed to shift contrasts for double-Y plot
      
      # break here to go to fit_model()
      # fit_model <- function(dt, xcols, grouping=FALSE, add_interaction=FALSE, intervals.mean='lm',  conf.mean=0.95,  intervals.contrast='lm',  contrasts.method='coefficients',  conf.contrast=0.95)
        
      res <- fit_model(dt, xcols, grouping, add_interaction, intervals.mean, conf.mean,
                       intervals.contrast, contrasts.method, conf.contrast)
      ci_means <- res$ci_means
      ci_diffs <- res$ci_diffs
      
      # add ybar to y
      x_levels <- ci_diffs[,x]
      ci_diffs[, x:=factor(x, levels=x_levels)]
      ci_diffs[, y:=y+ybar] # will be corrected by sec.axis in ggplot
      ci_diffs[, lower:=lower+ybar] # will be corrected by sec.axis in ggplot
      ci_diffs[, upper:=upper+ybar] # will be corrected by sec.axis in ggplot
      
      #     contrast intervals
      m_levels <- levels(dt[,x]) # levels for means plot
      g_levels <- levels(dt[,g])
      n_levels <- length(m_levels)
      n_groups <- length(g_levels)
      
      # make a dummy x for categorical variables for means
      c_levels <- levels(ci_diffs[,x]) # levels for contrast plot
      n_contrasts <- length(c_levels)
      width <- 0.8
      offset <- mean(1:n_groups/n_groups)
      contraction <- 1/ceiling(n_groups/2)
      dt[, x.d:=as.numeric(factor(x))]
      dt[, x.d:=(x.d + width*(as.numeric(factor(g))/n_groups - offset))]
      ci_means[, x.d:=as.numeric(factor(x))]
      ci_means[, x.d:=(x.d + width*(as.numeric(factor(g))/n_groups - offset))]
      contrast_breaks <- seq(from=(n_levels+1), to=(n_levels+1 + n_contrasts*contraction - contraction), by=contraction)
      ci_diffs[, x.d:= contrast_breaks]
      
      dt <- rbind(data.table(estimate='means',dt),
                  data.table(estimate='contrasts',ci_diffs[,.SD,.SDcols=c('x','g','y','x.d')]))
      ci <- rbind(data.table(estimate='means',ci_means),
                  data.table(estimate='contrasts',ci_diffs))
      dt[, x.fac:=x]
      ci[, x.fac:=x]
      dt[, x:=x.d]
      ci[, x:=x.d]
      
      # set x-axis breaks and bounds
      # breaks = 1:hi, label=levels(dt[,x.fac][lo:hi]), limits = c((lo-0.5), (hi+0.5)),
      if(show.treatments == FALSE){
        lo <- NA
        hi <- NA
        breaks <- NULL
        break_labels <- NULL
      }else{
        lo <- min(dt[, x])
        hi <- max(dt[estimate=='means', x])
        breaks <- 1:n_levels
        break_labels <- m_levels
      }
      if(show.contrasts == TRUE){
        if(is.na(lo)){
          lo <- n_levels+1
        }
        hi <- max(dt[, x])
        breaks <- c(breaks, contrast_breaks)
        break_labels <-c(break_labels, c_levels)
      }
      guide.boxplot <- FALSE
      guide.dots <- FALSE
      if(grouping==TRUE){
        #guide.boxplot <- ifelse(display.treatment=='box',TRUE,FALSE)
        guide.boxplot <- TRUE
        guide.dots <- ifelse(guide.boxplot==TRUE,FALSE,TRUE)
      }
      
      # x transformed to x.d and categorical x put into x.fac above 
      gg <- ggplot(data=dt, aes(x=x, y=y))
      
      # plot dots/mean/boxplot
      if(show.treatments == TRUE){
        #        for(i in 1:n_groups){
        if(display.treatment=='box'){ # plot before dots
          if(input$dots==TRUE){outlier_color <- NA}else{outlier_color <- NULL}
          gg <- gg + geom_boxplot(data=dt[estimate=='means',], aes(group=x, fill=g), outlier.colour = outlier_color, show.legend = guide.boxplot)
          if(guide.boxplot==TRUE){gg <- gg + guides(fill = guide_legend(input$group))}else{
            gg <- gg + guides(fill=FALSE)
          }
        }
        if(input$dots==TRUE){
          gg <- gg + geom_jitter(data=dt[estimate=='means',], aes(x=x,y=y), width = (0.8*0.5)/n_groups/2, height = 0.0, show.legend = guide.dots, color='black', alpha=0.5)
          if(guide.dots==TRUE){gg <- gg + guides(color = guide_legend(input$group))}else{
            gg <- gg+ guides(color=FALSE)
          }
        }
        if(display.treatment=='ci'){
          gg <- gg + geom_linerange(data=ci[estimate=='means',], aes(ymin = lower, ymax = upper, color=g), size=2)
          if(guide.boxplot==TRUE){gg <- gg + guides(color = guide_legend(input$group))}else{
            gg <- gg + guides(color=FALSE)
          }
        }
        if(show.mean==TRUE){
          dot_color <- ifelse(color_palette=='Greys','red','black')
          gg <- gg + geom_point(data=ci[estimate=='means',], aes(x=x,y=y), size=3, color='white')
          gg <- gg + geom_point(data=ci[estimate=='means',], aes(x=x,y=y), size=2, color=dot_color)
        }
      }
      
      # plot contrasts
      if(show.contrasts == TRUE){
        gg <- gg + geom_linerange(data=ci[estimate=='contrasts',], aes(ymin = lower, ymax = upper), color='black', size=2)
        gg <- gg + geom_point(data=ci[estimate=='contrasts',], aes(x=x,y=y), size=3, color='white')
        gg <- gg + geom_point(data=ci[estimate=='contrasts',], aes(x=x,y=y), size=2, color='black')
        gg <- gg + scale_y_continuous(sec.axis = sec_axis(~.-ybar, name = "Difference"))
        if(show.treatments == TRUE){
          gg <- gg + geom_vline(xintercept=n_levels+0.5, size=1, color='darkgrey')
        }
      }
      
      gg <- gg + labs(x=input$treatment, y=input$response)
      
      # build X axes
      pos_labels <- c((n_levels+1)/2, median(contrast_breaks))
      contrast_txt <- ifelse(contrasts.method=='coefficients', 'Coefficient', 'Contrast')
      gg <- gg + scale_x_continuous(
        breaks = breaks, label=break_labels, 
        # limits = c((lo-contraction/2), (hi+contraction/2)),
        sec.axis = sec_axis(~.+0, breaks=pos_labels, labels=c(input$treatment, contrast_txt)))
      
      # set colors
      if(color_palette != 'ggplot'){
        gg <- gg + scale_color_brewer(palette = color_palette)
        gg <- gg + scale_fill_brewer(palette = color_palette)
      }
      
      # set theme
      if(jtheme=='grey'){gg <- gg + theme_grey(base_size = 18)}
      if(jtheme=='gray'){gg <- gg + theme_gray(base_size = 18)}
      if(jtheme=='bw'){gg <- gg + theme_bw(base_size = 18)}
      if(jtheme=='classic'){gg <- gg + theme_classic(base_size = 18)}
      if(jtheme=='minimal'){gg <- gg + theme_minimal(base_size = 18)}
      
      if(input$flip==TRUE){
        gg <- gg + coord_flip()
        gg <- gg + theme(axis.title.y = element_blank(),
                         axis.text.y.right= element_text(angle = -90, hjust = 0.5),
                         legend.position = 'bottom')
      }else{
        gg <- gg + theme(axis.title.x = element_blank())
      }
      
      
      plots$p1 <- gg
      gg
      
      
    }
  }
  
  
  # output contrast interval method
  output$interval_text <- renderText({
    df <-datasetInput()
    if (is.null(df)) return(NULL)
    #    if(input$treatment != ' ' & input$response != ' '){
    if(input$intervals.contrast!=1){ #bootstrap or bayes
      adjust_text <- 'no'
    }else{
      if(input$adjust==FALSE){adjust_text <- 'none'}else{
        adjust_text <- ifelse(input$contrasts.method==2, 'Dunnet t approximation','Tukey HSD')
      }
    }
    conf <- c(0.99, 0.95, 0.9)
    conf.contrast <- as.integer(conf[as.numeric(as.character(input$conf.contrast))]*100)
    out_text <- paste('contrasts with ',conf.contrast,'% CI using adjustment: ',adjust_text, sep='')
    out_text
    #    }
  })
  
  # plot to the model panel
  output$hDotPlot.model <- renderPlot({
    df <-datasetInput()
    if (is.null(df)) return(NULL)
    if(input$treatment != ' ' & 
       input$response != ' '){
      print(plotInput())
    }
  })  
  
  # plot to the plot panel
  output$hDotPlot.plot <- renderPlot({
    df <-datasetInput()
    if (is.null(df)) return(NULL)
    if(input$treatment != ' ' & 
       input$response != ' '){
      print(plotInput())
    }
  })  
  
  output$formulaCaption <- renderText({
    dt <-datasetInput()
    if (is.null(dt)) return(NULL)
    "The Model"
  })
  
  output$modelFormula <- renderPrint({
    dt <-datasetInput()
    if (is.null(dt)) return(NULL)
    print(formula(tables$form_str), showEnv=FALSE)
  })
  
  output$contrastsCaption <- renderText({
    dt <-datasetInput()
    if (is.null(dt)) return(NULL)
    "Model Contrasts"
  })
  
  output$modelContrasts <- renderPrint({
    dt <-datasetInput()
    if (is.null(dt)) return(NULL)
    print(tables$contrasts)
  })
  
  output$coefCaption <- renderText({
    dt <-datasetInput()
    if (is.null(dt)) return(NULL)
    "Model Coefficients"
  })
  
  output$modelCoefficients <- renderPrint({
    dt <-datasetInput()
    if (is.null(dt)) return(NULL)
    print(tables$coeffs)
  })
  
  output$sumCaption <- renderText({
    dt <-datasetInput()
    if (is.null(dt)) return(NULL)
    "Model Summary"
  })
  
  output$modelSummary <- renderPrint({
    dt <-datasetInput()
    if (is.null(dt)) return(NULL)
    tables$summary
  })
  
  output$meansCaption <- renderText({
    dt <-datasetInput()
    if (is.null(dt)) return(NULL)
    "Model Means"
  })
  
  output$modelMeans <- renderPrint({
    dt <-datasetInput()
    if (is.null(dt)) return(NULL)
    tables$means
  })
  
  
  output$modelCode <- renderPrint({
    dt <-datasetInput()
    if (is.null(dt)) return(NULL)
    str1 <- 'library(ggplot2)'
    str2 <- 'library(lsmeans)'
    str3 <- 'library(broom)'
    str4 <- 'library(data.table)'
    h <- paste(str1, str2, str3, str4, sep = '<br/>')
    # for(i in 1:lengths(code$fit)){
    #   h <- paste(h, code$fit[[i]], sep = '<br/>')
    # }
    HTML(h)
  })
  
  # download
  # output$downloadPlot <- downloadHandler(
  #   filename = 'temp.png',
  #   content = function(file) {
  #     device <- function(..., width, height) grDevices::png(..., width = width, height = height, res = 300, units = "in")
  #     ggsave(file, plot = plotInput(), device = device)
  #   }
  # )
  
  output$downloadPlot = downloadHandler(
    filename = function() {"Hdotplot.pdf"},
    content = function(file) {
      pdf(file, width=input$width, height=input$height, onefile = TRUE)
      grid.arrange(plots$p1) 
      dev.off()
    }
  )
  
}


# Run the application 
shinyApp(ui = ui, server = server)

