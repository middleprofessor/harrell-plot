# "Harrell" or "horizontal" dot plot - defaults to ploting treatment contrasts
# in upper panel and treatment boxplots in lower planel
# Jeffrey A. Walker
# November 24, 2017

library(shiny)
library(gridExtra) # needed for download
library(ggplot2)
library(data.table)
library(Hmisc)
library(MCMCpack)
library(coda)
library(lsmeans)


# Define UI for application that draws a histogram
ui <- fluidPage(
  
  # sidebarLayout(
  # App title ----
  titlePanel("Hdotplot"),
  
  # Sidebar panel for inputs ----
  sidebarPanel(
    conditionalPanel(condition = "input.tabs=='Model'",
                     # Input file
                     fileInput("FileInput", "Choose file"),
                     
                     h3("Model"),
                     # reactive Input for treatment
                     uiOutput("treatment"),
                     # reactive Input for response
                     uiOutput("response"),
                     # reactive Input for grouping
                     uiOutput("group"),
                     
                     # contrast method
                     selectInput("contrasts.method", h3("Contrasts"), 
                                 choices = list("Hide" = 1, "vs. Control" = 2, "Pairwise" = 3), selected = 2),
                     # Input: Checkbox for multiple tests
                     checkboxInput("adjust", "Adjust for multiple tests", FALSE),
                     # Input: Confidence level
                     selectInput("conf.contrast", h5("Confidence level"), 
                                 choices = list("99%" = 1, "95%" = 2, "90%" = 3), selected = 2),
                     # Input: Contrasts Confidence Interval Model
                     selectInput("intervals.contrast", h5("Contrasts CI model"), 
                                 choices = list("lm" = 1), selected = 1),

                     # Input: Checkbox for dots ----
                     selectInput("display.mean", h3("Treatments"), 
                                 choices = list("Hide" = 1, "Box plot" = 2, "Confidence Interval" = 3), selected = 2),
                     checkboxInput("dots", "Show dots", TRUE),
                     # Input: Checkbox for Mean
                     checkboxInput("mean", "Show Mean", FALSE),
                     # # Input: Checkbox for CI ----
                     # checkboxInput("box", "Show Box plot", TRUE),
                     # # Input: Checkbox for CI ----
                     # checkboxInput("ci", "Confidence Interval", FALSE),
                     
                     # Input: Confidence level
                     selectInput("conf.mean", h5("Confidence level"), 
                                 choices = list("99%" = 1, "95%" = 2, "90%" = 3), selected = 2),
                     
                     # Input: Confidence Interval Model
                     # selectInput("intervals.mean", h5("Treatment CI model"), 
                     #       choices = list("raw" = 1, "lm" = 2, "bootstrap" = 3, "Bayesian" = 4), selected = 1),
                     selectInput("intervals.mean", h5("Treatment CI model"), 
                                 choices = list("raw" = 1, "lm" = 2, "bootstrap" = 3), selected = 1)
                     
                     
    ),

    conditionalPanel(condition = "input.tabs=='Plot'",
                     h3("Plot"),
                     # Input: colors
                     #    selectInput("colors", h5("Plot Colors"), 
                     #                choices = list("grays" = 1, "blues" = 2, "reds" = 3), selected = 1),
                     # Input: theme
                     selectInput("theme", h5("Plot Theme"), 
                                 choices = list("gray" = 1, "bw" = 2, "classic" = 3, "minimal" = 4), selected = 1),
                     # Input: flip axes ----
                     checkboxInput("flip", "Horizontal bars", TRUE),
                     
                     # Input: abbreviate factor levels
                     checkboxInput("short", "Abbreviate factor levels", FALSE)
    ),
    
    conditionalPanel(condition = "input.tabs=='Save'",
                     h3("Download"),
                     numericInput("width", "Width (inches)", 7, min = 2, max = 10, step = 0.25),
                     numericInput("height", "Height (inches)", 5, min = 2, max = 10, step = 0.25)
                     
    )
    
  ),
  
  # Main panel for displaying outputs ----
  mainPanel(
    
    tabsetPanel(type = "tabs",
                 tabPanel("Model",
                          # Output: CI level and adjustment for contrasts
                          textOutput("interval_text"),
                          
                          # Output: Plot
                          plotOutput("hDotPlot.model", width = "100%", height = "600px")
                 ),
                tabPanel("Plot",
                         # Output: Plot
                         plotOutput("hDotPlot.plot", width = "100%", height = "600px")
                         ),
                tabPanel("Save",
                         
                         # print the plot
                         downloadButton(outputId = "downloadPlot", label = "Download the plot")
                ),
                id = 'tabs'
    )
    
  )
  #  )
)


# Define server logic to plot various variables against mpg ----
server <- function(input, output) {
  # global variable for downloading plot
  plots <- reactiveValues(p1=NULL)
  
  # populate Treatment input
  output$treatment <- renderUI({
    df <-datasetInput()
    if (is.null(df)) return(NULL)
    items=c(' ', names(df))
    #    names(items)=items
    selectInput("treatment", "Treatment",items)
  })
  
  # populate Response input
  output$response <- renderUI({
    df <-datasetInput()
    if (is.null(df)) return(NULL)
    items=c(' ', names(df))
    #    names(items)=items
    selectInput("response", "Response",items)
  })
  
  # populate Group input
  output$group <- renderUI({
    df <-datasetInput()
    if (is.null(df)) return(NULL)
    items=c(' ', names(df))
    #    names(items)=items
    selectInput("group", "Grouping",items)
  })
  
  
  #  the function to plot the data
  # read data file
  datasetInput <- reactive({
    infile <- input$FileInput
    if(is.null(infile))
      return(NULL)
    #read.csv(infile$datapath, header = TRUE)
    fread(infile$datapath, stringsAsFactors = TRUE)
  })
  
  form <- function(y, xcols){
    form_str <- paste(y, ' ~ ', paste(xcols, collapse=' + '), sep='')
    # if(input$interaction==TRUE & length(xcols)==2){
    #   form_str <- paste(form_str, paste(xcols[1],':',xcols[2], sep=''), sep = ' + ')
    # }
    return(form_str)
  }
  
  plotInput <- function(){
    df <-datasetInput()
    if (is.null(df)) return(NULL)
    if(is.numeric(df[[input$response]]) & is.factor(df[[input$treatment]])){
      #set inputs to non-shiny variables
      # confidence limits for contrasts and means
      conf <- c(0.99, 0.95, 0.9)
      conf.contrast <- conf[as.numeric(as.character(input$conf.contrast))]
      conf.mean <- conf[as.numeric(as.character(input$conf.mean))]
      
      # contrasts
      # method for computation of treatment CI
      interval_array <- c('lm','boot','bayes')
      intervals.contrast <- interval_array[as.numeric(as.character(input$intervals.contrast))]
      # control or pairwise contrasts
      contrast_array <- c('trt.vs.ctrl1', 'revpairwise') # c("Control", "Pairwise") in menu 
      contrasts.method <- contrast_array[as.numeric(as.character(input$contrasts.method))]
      # adjust for multiple tests
      if(input$adjust==FALSE){adjust <- FALSE}else{adjust <- TRUE}
      
      # treatments
      input_array <- c('none','box','ci')
      display.mean <- input_array[as.numeric(as.character(input$display.mean))]
      # method for computation of treatment CI
      interval_array <- c('raw','lm','boot','bayes')
      intervals.mean <- interval_array[as.numeric(as.character(input$intervals.mean))]
      
      # grouping
      if(input$group==' '){grouping <- FALSE}else{grouping <- TRUE}
      
      # plot
      # themes
      theme_array <- c("gray", "bw", "classic", "minimal")
      jtheme <- theme_array[as.numeric(as.character(input$theme))]
      if(input$short==FALSE){short <- FALSE}else{short <- TRUE}
      
      dt <- data.table(x = df[[input$treatment]], g = '', y = df[[input$response]])
      xcols <- 'x'
      if(grouping == TRUE){
        dt[,g:=df[[input$group]]]
        xcols <- c('x','g')
      }
      dt <- na.omit(dt)
      if(short==TRUE){
        dt[,x:=abbreviate(x)]
        dt[,g:=abbreviate(g)]
      }
      dt[,x:=factor(x, dt[,.(i=min(.I)),by=x][,x])]
      dt[,g:=factor(g, dt[,.(i=min(.I)),by=g][,g])]
      ybar <- mean(dt[,y]) # needed to shift contrasts for double-Y plot
      
      #     linear model
      # if(grouping==FALSE){
      #   fit <- lm(y ~ x, data=dt)
      #   lsm <- lsmeans(fit, specs='x')
      # }else{ #if grouping==TRUE
      #   fit.g <- lm(y ~ x + g, data=dt)
      #   lsm.g <- lsmeans(fit, specs=c('x','g'))
      # }
      form <- formula(paste('y ~ ', paste(xcols, collapse=' + '), sep=''))
      fit <- lm(form, data=dt)
      lsm <- lsmeans(fit, specs=xcols)
      if(grouping==TRUE){
        lsm.x <- lsmeans(fit, specs='x')
        lsm.g <- lsmeans(fit, specs='g')
        contrast(lsmeans(fit, specs=c('x'), by='g'))
        contrast(lsmeans(fit, specs=c('x','g')), by='g') #same
      }
      
      #     Bayes model
      #  mad <- median(abs(dt[,y] - mean(dt[,y])))
      #  #dt[,y.mad:=y/mad]
      #  y.mad <- dt[,y]/mad
      #  fit.mcmc <- MCMCregress(y.mad ~ x, data=dt, b0 = 0, B0 = 0.1, c0=2, d0=0.11)
      #  post.lsm <- lsmeans(fit.mcmc, specs='x')
      # # dt <- dt[, .SD, .SDcols=c('x','y')] #drop y.mad because need to bind ci later
      
      # means intervals
      if(intervals.mean=='lm'){
        ci_means <- data.table(confint(lsm, level=conf.mean)) # mean intervals not adjusted
        ci_means <- ci_means[, .SD, .SDcols=c(xcols,'lsmean','lower.CL','upper.CL')]
      }
      if(intervals.mean=='raw'){
        conf.tail <- conf.mean + (1-conf.mean)/2
        ci_means <- dt[, .(
          mean=mean(y),
          lower=mean(y)-sd(y)/sqrt(.N)*qt(conf.tail,(.N-1)),
          upper=mean(y)+sd(y)/sqrt(.N)*qt(conf.tail,(.N-1))),
          by=xcols]
      }
      if(intervals.mean=='boot'){
        dt_boot <- data.table(dt[, smean.cl.boot(y,conf.int=conf.mean), by=xcols])
        dt_boot[, tile:=c('a','lower','upper')]
        form <- formula(paste(paste(xcols,collapse='+'),'tile',sep='~'))
        ci_means <- dcast(dt_boot, form, value.var='V1') #**** change x+g to formula
      }
      if(intervals.mean=='bayes'){
        conf.tail <- conf.mean + (1-conf.mean)/2
        res <- summary(as.mcmc(post.lsm), quantiles = c(0.5, (1-conf.tail), conf.tail))$quantiles*mad
        ci_means <- data.table(x=row.names(res),res)
        ci_means[, x:=factor(substr(x,3,nchar(x)))]
      }
      if(grouping==FALSE){
        ci_means[, g:='']
        setnames(ci_means, old=colnames(ci_means), new=c('x','y','lower','upper','g'))
        ci_means <- ci_means[,.SD, .SDcols=c('x','g','y','lower','upper')]
      }else{
        setnames(ci_means, old=colnames(ci_means), new=c(xcols,'y','lower','upper'))
      }
      
      #     contrast intervals
      m_levels <- levels(dt[,x]) # levels for means plot
      g_levels <- levels(dt[,g])
      n_levels <- length(m_levels)
      n_groups <- length(g_levels)
      
      if(intervals.contrast=='lm'){
        if(adjust==FALSE){ # defaults to different adjustment based on contrasts and I cannot see to do this in 1 line
          ci_diffs <- data.table(confint(contrast(lsm, method=contrasts.method), adjust='none', level=conf.contrast))
          ci_diffs[, g:=NA]
          if(grouping==TRUE){
            if(contrasts.method=='revpairwise'){
              p_levels <- n_levels*(n_levels-1)/2
              p_groups <- n_groups*(n_groups-1)/2
            }else{
              p_levels <- n_levels-1
              p_groups <- n_groups-1
            }
            ci_diff.x <- data.table(confint(contrast(lsm, method=contrasts.method, by='g'), adjust='none', level=conf.contrast))[1:p_levels]
            ci_diff.x[, g:=input$treatment]
            ci_diff.g <- data.table(confint(contrast(lsm, method=contrasts.method, by='x'), adjust='none', level=conf.contrast))[1:p_groups]
            setnames(ci_diff.g, old=c('x'), new='g')
            ci_diff.x[, g:=input$group]
            ci_diffs <- rbind(ci_diff.x, ci_diff.g)
          }
        }else{
          ci_diffs <- data.table(confint(contrast(lsm, method=contrasts.method), level=conf.contrast))
        }
        ci_diffs <- ci_diffs[, .SD, .SDcols=c('contrast','g','estimate','lower.CL','upper.CL')]
      }
      if(intervals.contrast=='bayes'){
        conf.tail <- conf.contrast + (1-conf.contrast)/2
        res <- summary(as.mcmc(contrast(post.lsm, method=contrasts.method)), quantiles = c(0.5, (1-conf.tail), conf.tail))$quantiles*mad
        ci_diffs <- data.table(x=row.names(res),res)
        ci_diffs[, x:=factor(substr(x,10,nchar(x)))]
      }
      
      setnames(ci_diffs, old=colnames(ci_diffs), new=c('x','g','y','lower','upper'))
      # cut to relevant rows
      # if(contrasts.method=='trt.vs.ctrl1'){
      #   nx <- length(levels(dt[,x])) - 1
      #   inc <- 1:nx
      #   if(grouping==TRUE){
      #     ng <- length(levels(dt[,factor(g)])) - 1
      #     inc <- c(inc, seq(from=(nx+1), to=nrow(ci_diffs), by=(ng)))
      #   }
      #   ci_diffs <- ci_diffs[inc,]
      #   ci_diffs[, x:=factor(as.character(x))]
      # }
      
      ci_diffs[, y:=y+ybar] # will be corrected by sec.axis in ggplot
      ci_diffs[, lower:=lower+ybar] # will be corrected by sec.axis in ggplot
      ci_diffs[, upper:=upper+ybar] # will be corrected by sec.axis in ggplot
      
      # dt <- rbind(data.table(estimate='means',dt),
      #             data.table(estimate='contrasts',ci_diffs[,.SD,.SDcols=c('x','g','y')]))
      # ci <- rbind(data.table(estimate='means',ci_means),
      #             data.table(estimate='contrasts',ci_diffs[,.SD,.SDcols=c('x', 'g', 'y', 'lower', 'upper')]))
      # dt[,x:=factor(x, levels=c(m_levels, c_levels))]
      # ci[,x:=factor(x, levels=c(m_levels, c_levels))]
      
      # make a dummy x for categorical variables for means
      c_levels <- levels(ci_diffs[,x]) # levels for contrast plot
      n_contrasts <- length(c_levels)
      width <- 0.8/n_groups
      offset <- mean(1:n_groups/n_groups)
      contraction <- 1/ceiling(n_groups/2)
      dt[, x.d:=as.numeric(factor(x))]
      dt[, x.d:=(x.d + as.numeric(factor(g))*width - offset)]
      ci_means[, x.d:=as.numeric(factor(x))]
      ci_means[, x.d:=(x.d + as.numeric(factor(g))*width - offset)]
      contrast_breaks <- seq(from=(n_levels+1), to=(n_levels+1 + n_contrasts*contraction - contraction), by=contraction)
      ci_diffs[, x.d:= contrast_breaks]
      
      dt <- rbind(data.table(estimate='means',dt),
                  data.table(estimate='contrasts',ci_diffs[,.SD,.SDcols=c('x','g','y','x.d')]))
      ci <- rbind(data.table(estimate='means',ci_means),
                  data.table(estimate='contrasts',ci_diffs))
      dt[, x.fac:=x]
      ci[, x.fac:=x]
      dt[, x:=x.d]
      ci[, x:=x.d]
      
      # set x-axis breaks and bounds
      # breaks = 1:hi, label=levels(dt[,x.fac][lo:hi]), limits = c((lo-0.5), (hi+0.5)),
      if(display.mean == 'none'){
        lo <- n_levels+1
        breaks <- NULL
        break_labels <- NULL
      }else{
        lo <- 1
        breaks <- 1:n_levels
        break_labels <- m_levels
      }
      display.contrasts <- TRUE
      if(display.contrasts == TRUE){
        hi <- max(dt[, x.d])
        breaks <- c(breaks, contrast_breaks)
        break_labels <-c(break_labels, c_levels)
      }
      
      gg <- ggplot(data=dt, aes(x=x.d, y=y))
      
      # plot dots/mean/boxplot
      if(display.mean != 'none'){
        #        for(i in 1:n_groups){
        if(display.mean=='box'){ # plot before dots
          if(input$dots==TRUE){outlier_color <- NA}else{outlier_color <- NULL}
          gg <- gg + geom_boxplot(data=dt[estimate=='means',], aes(group=x, fill=g), outlier.colour = outlier_color)
          gg <- gg + guides(fill = guide_legend(input$group))
        }
        if(input$dots==TRUE){
          gg <- gg + geom_jitter(data=dt[estimate=='means',], aes(x=x,y=y), width = 0.1, height = 0.0, color='darkgray')
        }
        if(input$mean==TRUE){
          #      gg <- gg + stat_summary(fun.y=mean, geom='point',color='black', size=2)
          gg <- gg + geom_point(data=ci[estimate=='means',], aes(x=x,y=y), size=3, color='white')
          gg <- gg + geom_point(data=ci[estimate=='means',], aes(x=x,y=y), size=2, color='black')
        }
        if(display.mean=='ci'){
          gg <- gg + geom_linerange(data=ci[estimate=='means',], aes(ymin = lower, ymax = upper), color='black')
        }
        #      }
      }
      
      # plot contrasts
      gg <- gg + geom_linerange(data=ci[estimate=='contrasts',], aes(ymin = lower, ymax = upper), color='black')
      gg <- gg + geom_point(data=ci[estimate=='contrasts',], aes(x=x,y=y), size=3, color='white')
      gg <- gg + geom_point(data=ci[estimate=='contrasts',], aes(x=x,y=y), size=2, color='black')
      gg <- gg + scale_y_continuous(sec.axis = sec_axis(~.-ybar, name = "Difference"))
      if(display.mean != 'none'){
        gg <- gg + geom_vline(xintercept=n_levels+0.5, size=1, color='darkgrey')
      }
      
      gg <- gg + labs(x=input$treatment, y=input$response)
      
      # build X axes
      pos_labels <- c((n_levels+1)/2, median(contrast_breaks))
      gg <- gg + scale_x_continuous(
        breaks = breaks, label=break_labels,
        sec.axis = sec_axis(~.+0, breaks=pos_labels, labels=c(input$treatment,'Contrast')))
      
      if(jtheme=='grey'){gg <- gg + theme_grey(base_size = 18)}
      if(jtheme=='gray'){gg <- gg + theme_gray(base_size = 18)}
      if(jtheme=='bw'){gg <- gg + theme_bw(base_size = 18)}
      if(jtheme=='classic'){gg <- gg + theme_classic(base_size = 18)}
      if(jtheme=='minimal'){gg <- gg + theme_minimal(base_size = 18)}
      
      if(input$flip==TRUE){
        gg <- gg + coord_flip()
        gg <- gg + theme(axis.title.y = element_blank(),
                         axis.text.y.right= element_text(angle = -90, hjust = 0.5),
                         legend.position = 'bottom')
      }else{
        gg <- gg + theme(axis.title.x = element_blank())
      }
      
      
      plots$p1 <- gg
      gg
      
      
    }
  }
  
  
  # output contrast interval method
  output$interval_text <- renderText({
    df <-datasetInput()
    if (is.null(df)) return(NULL)
    
    if(input$intervals.contrast!=1){ #bootstrap or bayes
      adjust_text <- 'no'
    }else{
      if(input$adjust==FALSE){adjust_text <- 'no'}else{
        if(input$contrasts.method==1){adjust_text <- 'Dunnet t approximation'}else{adjust_text <- 'Tukey HSD'}
      }
    }
    conf <- c(0.99, 0.95, 0.9)
    conf.contrast <- as.integer(conf[as.numeric(as.character(input$conf.contrast))]*100)
    out_text <- paste('contrasts with ',conf.contrast,'% CI using ',adjust_text, ' adjustment', sep='')
    out_text
  })
  
  # plot to the main panel
  output$hDotPlot.model <- renderPlot({
    print(plotInput())
  })  
  
  # plot to the main panel
  output$hDotPlot.plot <- renderPlot({
    print(plotInput())
  })  
  
  # download
  # output$downloadPlot <- downloadHandler(
  #   filename = 'temp.png',
  #   content = function(file) {
  #     device <- function(..., width, height) grDevices::png(..., width = width, height = height, res = 300, units = "in")
  #     ggsave(file, plot = plotInput(), device = device)
  #   }
  # )
  
  output$downloadPlot = downloadHandler(
    filename = function() {"Hdotplot.pdf"},
    content = function(file) {
      pdf(file, width=input$width, height=input$height, onefile = TRUE)
      grid.arrange(plots$p1) 
      dev.off()
    }
  )
  
}


# Run the application 
shinyApp(ui = ui, server = server)

