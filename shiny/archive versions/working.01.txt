# "Harrell" or "horizontal" dot plot - defaults to ploting treatment contrasts
# in upper panel and treatment boxplots in lower planel
# Jeffrey A. Walker
# November 24, 2017

library(shiny)
library(gridExtra) # needed for download
library(ggplot2)
library(data.table)
library(Hmisc)
library(MCMCpack)
library(coda)
library(lsmeans)


# Define UI for application that draws a histogram
ui <- fluidPage(
  
  # App title ----
  titlePanel("Hdotplot"),
  
  # Sidebar panel for inputs ----
  sidebarPanel(
    # Input file
    fileInput("FileInput", "Choose file"),
    
    # reactive Input for treatment
    uiOutput("treatment"),
    # reactive Input for response
    uiOutput("response"),
    # reactive Input for grouping
    uiOutput("group"),
    
    # contrast method
    selectInput("contrasts.method", h3("Contrasts"), 
                choices = list("vs. Control" = 1, "Pairwise" = 2), selected = 1),
    # Input: Checkbox for multiple tests
    checkboxInput("adjust", "Adjust for multiple tests", FALSE),
    # Input: Confidence level
    selectInput("conf.contrast", h5("Confidence level"), 
                choices = list("99%" = 1, "95%" = 2, "90%" = 3), selected = 2),
    # Input: Contrasts Confidence Interval Model
    selectInput("intervals.contrast", h5("Contrasts CI model"), 
                choices = list("lm" = 1), selected = 1),
    # selectInput("intervals.contrast", h5("Contrasts CI model"), 
    #             choices = list("lm" = 1, "bootstrap" = 2, "Bayesian" = 3 ), selected = 1),
    
    # Input: Checkbox for dots ----
    selectInput("display.mean", h3("Treatments"), 
                choices = list("Don't show" = 1, "Box plot" = 2, "Confidence Interval" = 3), selected = 2),
    checkboxInput("dots", "Show dots", TRUE),
    # Input: Checkbox for Mean
    checkboxInput("mean", "Show Mean", FALSE),
    # # Input: Checkbox for CI ----
    # checkboxInput("box", "Show Box plot", TRUE),
    # # Input: Checkbox for CI ----
    # checkboxInput("ci", "Confidence Interval", FALSE),
    
    # Input: Confidence level
    selectInput("conf.mean", h5("Confidence level"), 
                choices = list("99%" = 1, "95%" = 2, "90%" = 3), selected = 2),
    
    # Input: Confidence Interval Model
    # selectInput("intervals.mean", h5("Treatment CI model"), 
    #       choices = list("raw" = 1, "lm" = 2, "bootstrap" = 3, "Bayesian" = 4), selected = 1),
    selectInput("intervals.mean", h5("Treatment CI model"), 
                choices = list("raw" = 1, "lm" = 2, "bootstrap" = 3), selected = 1),
    
    h3("Plot"),
    # Input: colors
    #    selectInput("colors", h5("Plot Colors"), 
    #                choices = list("grays" = 1, "blues" = 2, "reds" = 3), selected = 1),
    # Input: theme
    selectInput("theme", h5("Plot Theme"), 
                choices = list("gray" = 1, "bw" = 2, "classic" = 3, "minimal" = 4), selected = 1),
    # Input: flip axes ----
    checkboxInput("flip", "Horizontal bars", TRUE),
    
    # Input: abbreviate factor levels
    checkboxInput("short", "Abbreviate factor levels", FALSE),
    
    h3("Download"),
    numericInput("width", "Width (inches)", 7, min = 2, max = 10, step = 0.25),
    numericInput("height", "Height (inches)", 5, min = 2, max = 10, step = 0.25)
    
    
  ),
  
  # Main panel for displaying outputs ----
  mainPanel(
    
    
    # Output: Plot of the requested variable against mpg ----
    plotOutput("jPlot"),
    
    # Output: CI level and adjustment for contrasts
    textOutput("interval_text"),
    
    # print the plot
    downloadButton(outputId = "downloadPlot", label = "Download the plot")
  )
)


# Define server logic to plot various variables against mpg ----
server <- function(input, output) {
  # global variable for downloading plot
  plots <- reactiveValues(p1=NULL)
  
  # populate Treatment input
  output$treatment <- renderUI({
    df <-datasetInput()
    if (is.null(df)) return(NULL)
    items=c(' ', names(df))
#    names(items)=items
    selectInput("treatment", "Treatment",items)
  })
  
  # populate Response input
  output$response <- renderUI({
    df <-datasetInput()
    if (is.null(df)) return(NULL)
    items=c(' ', names(df))
    #    names(items)=items
    selectInput("response", "Response",items, selected=items[2])
  })

  # populate Treatment input
  output$group <- renderUI({
    df <-datasetInput()
    if (is.null(df)) return(NULL)
    items=c(' ', names(df))
    #    names(items)=items
    selectInput("group", "Grouping",items)
  })
  
  
  #  the function to plot the data
  # read data file
  datasetInput <- reactive({
    infile <- input$FileInput
    if(is.null(infile))
      return(NULL)
    #read.csv(infile$datapath, header = TRUE)
    fread(infile$datapath, stringsAsFactors = TRUE)
  })
  
  plotInput <- function(){
    df <-datasetInput()
    if (is.null(df)) return(NULL)
    if(is.numeric(df[[input$response]]) & is.factor(df[[input$treatment]])){
      #set inputs to non-shiny variables
      # confidence limits for contrasts and means
      conf <- c(0.99, 0.95, 0.9)
      conf.contrast <- conf[as.numeric(as.character(input$conf.contrast))]
      conf.mean <- conf[as.numeric(as.character(input$conf.mean))]
      
      # contrasts
      # method for computation of treatment CI
      interval_array <- c('lm','boot','bayes')
      intervals.contrast <- interval_array[as.numeric(as.character(input$intervals.contrast))]
      # control or pairwise contrasts
      contrast_array <- c('trt.vs.ctrl1', 'revpairwise') # c("Control", "Pairwise") in menu 
      contrasts.method <- contrast_array[as.numeric(as.character(input$contrasts.method))]
      # adjust for multiple tests
      if(input$adjust==FALSE){adjust <- FALSE}else{adjust <- TRUE}
      
      # treatments
      input_array <- c('none','box','ci')
      display.mean <- input_array[as.numeric(as.character(input$display.mean))]
      # method for computation of treatment CI
      interval_array <- c('raw','lm','boot','bayes')
      intervals.mean <- interval_array[as.numeric(as.character(input$intervals.mean))]
      
      # plot
      # themes
      theme_array <- c("gray", "bw", "classic", "minimal")
      jtheme <- theme_array[as.numeric(as.character(input$theme))]
      if(input$short==FALSE){short <- FALSE}else{short <- TRUE}
      
      xcols <- c(input$treatment, input$group)
      y <- input$response
      dt <- na.omit(data.table(x = df[[input$treatment]], y = df[[input$response]]))
      if(short==TRUE){dt[,x:=abbreviate(x)]}
      dt[,x:=factor(x, dt[,.(i=min(.I)),by=x][,x])]
      hi <- length(levels(dt[,x])) # needed to plot treatments only *not implemented
      ybar <- mean(dt[,y]) # needed to shift contrasts for double-Y plot
      
      #     linear model
      fit <- lm(y ~ x, data=dt)
      lsm <- lsmeans(fit, specs='x')
      
      #     Bayes model
      #  mad <- median(abs(dt[,y] - mean(dt[,y])))
      #  #dt[,y.mad:=y/mad]
      #  y.mad <- dt[,y]/mad
      #  fit.mcmc <- MCMCregress(y.mad ~ x, data=dt, b0 = 0, B0 = 0.1, c0=2, d0=0.11)
      #  post.lsm <- lsmeans(fit.mcmc, specs='x')
      # # dt <- dt[, .SD, .SDcols=c('x','y')] #drop y.mad because need to bind ci later
      
      # means intervals
      if(intervals.mean=='lm'){
        ci_means <- data.table(confint(lsm, level=conf.mean)) # mean intervals not adjusted
        ci_means <- ci_means[, .SD, .SDcols=c('x','lsmean','lower.CL','upper.CL')]
      }
      if(intervals.mean=='raw'){
        conf.tail <- conf.mean + (1-conf.mean)/2
        ci_means <- dt[,list(
          mean=mean(y),
          lower=mean(y)-sd(y)/sqrt(.N)*qt(conf.tail,(.N-1)),
          upper=mean(y)+sd(y)/sqrt(.N)*qt(conf.tail,(.N-1))),
          by=list(x)]
      }
      if(intervals.mean=='boot'){
        dt_boot <- data.table(dt[, smean.cl.boot(y,conf.int=conf.mean), by=x])
        dt_boot[, tile:=c('a','lower','upper')]
        ci_means <- dcast(dt_boot, x~tile, value.var='V1')
      }
      if(intervals.mean=='bayes'){
        conf.tail <- conf.mean + (1-conf.mean)/2
        res <- summary(as.mcmc(post.lsm), quantiles = c(0.5, (1-conf.tail), conf.tail))$quantiles*mad
        ci_means <- data.table(x=row.names(res),res)
        ci_means[, x:=factor(substr(x,3,nchar(x)))]
      }
      setnames(ci_means, old=colnames(ci_means), new=c('x','y','lower','upper'))
      
      #     contrast intervals
      if(intervals.contrast=='lm'){
        if(adjust==FALSE){ # defaults to different adjustment based on contrasts and I cannot see to do this in 1 line
          ci_diffs <- data.table(confint(contrast(lsm, method=contrasts.method), adjust='none', level=conf.contrast))
        }else{
          ci_diffs <- data.table(confint(contrast(lsm, method=contrasts.method), level=conf.contrast))
        }
        ci_diffs <- ci_diffs[, .SD, .SDcols=c('contrast','estimate','lower.CL','upper.CL')]
      }
      if(intervals.contrast=='bayes'){
        conf.tail <- conf.contrast + (1-conf.contrast)/2
        res <- summary(as.mcmc(contrast(post.lsm, method=contrasts.method)), quantiles = c(0.5, (1-conf.tail), conf.tail))$quantiles*mad
        ci_diffs <- data.table(x=row.names(res),res)
        ci_diffs[, x:=factor(substr(x,10,nchar(x)))]
      }
      setnames(ci_diffs, old=colnames(ci_diffs), new=c('x','y','lower','upper'))
      ci_diffs[, y:=y+ybar] # will be corrected by sec.axis in ggplot
      ci_diffs[, lower:=lower+ybar] # will be corrected by sec.axis in ggplot
      ci_diffs[, upper:=upper+ybar] # will be corrected by sec.axis in ggplot
      
      #      if(contrasts != 'none'){
      # bind diffs to data
      m_levels <- levels(dt[,x])
      c_levels <- levels(ci_diffs[,x])
      dt <- rbind(data.table(estimate='means',dt),
                  data.table(estimate='contrasts',ci_diffs[,.SD,.SDcols=c('x','y')]))
      ci <- rbind(data.table(estimate='means',ci_means),
                  data.table(estimate='contrasts',ci_diffs))
      dt[,x:=factor(x, levels=c(m_levels, c_levels))]
      ci[,x:=factor(x, levels=c(m_levels, c_levels))]
      #      }
      
      dt[, x.fac:=x]
      dt[, x:=as.integer(factor(x))]
      ci[, x.fac:=x]
      ci[, x:=as.integer(factor(x))]
      
      n_levels <- max(dt[estimate=='means',x])
      n_contrasts <- max(dt[,x]) - n_levels
      if(display.mean == 'none'){lo <- n_levels+1}else{lo <- 1}
      gg <- ggplot(data=dt, aes(x=x, y=y))
      
      if(display.mean != 'none'){
        if(display.mean=='box'){ # plot before dots
          if(input$dots==TRUE){outlier_color <- NA}else{outlier_color <- NULL}
          gg <- gg + geom_boxplot(data=dt[estimate=='means',], aes(group=x), color='black', outlier.colour = outlier_color)
        }
        if(input$dots==TRUE){
          gg <- gg + geom_jitter(data=dt[estimate=='means',], aes(x=x,y=y), width = 0.1, height = 0.0, color='darkgray')
        }
        if(input$mean==TRUE){
          #      gg <- gg + stat_summary(fun.y=mean, geom='point',color='black', size=2)
          gg <- gg + geom_point(data=ci[estimate=='means',], aes(x=x,y=y), size=3, color='white')
          gg <- gg + geom_point(data=ci[estimate=='means',], aes(x=x,y=y), size=2, color='black')
        }
        if(display.mean=='ci'){
          gg <- gg + geom_linerange(data=ci[estimate=='means',], aes(ymin = lower, ymax = upper), color='black')
        }
      }
      
      # plot contrasts
      hi <- length(levels(dt[,x.fac]))
      gg <- gg + geom_linerange(data=ci[estimate=='contrasts',], aes(ymin = lower, ymax = upper), color='black')
      gg <- gg + geom_point(data=ci[estimate=='contrasts',], aes(x=x,y=y), size=3, color='white')
      gg <- gg + geom_point(data=ci[estimate=='contrasts',], aes(x=x,y=y), size=2, color='black')
      gg <- gg + scale_y_continuous(sec.axis = sec_axis(~.-ybar, name = "Difference"))
      if(display.mean != 'none'){
        gg <- gg + geom_vline(xintercept=n_levels+0.5, size=1, color='darkgrey')
      }
      
      gg <- gg + labs(x=input$treatment, y=input$response)
      
      # build X axes
      pos_labels <- c((n_levels+1)/2, n_levels + (n_contrasts+1)/2)
      gg <- gg + scale_x_continuous(
        breaks = 1:hi, label=levels(dt[,x.fac][lo:hi]), limits = c((lo-0.5), (hi+0.5)),
        sec.axis = sec_axis(~.+0, breaks=pos_labels, labels=c(input$treatment,'Contrast')))
      
      if(jtheme=='grey'){gg <- gg + theme_grey(base_size = 18)}
      if(jtheme=='gray'){gg <- gg + theme_gray(base_size = 18)}
      if(jtheme=='bw'){gg <- gg + theme_bw(base_size = 18)}
      if(jtheme=='classic'){gg <- gg + theme_classic(base_size = 18)}
      if(jtheme=='minimal'){gg <- gg + theme_minimal(base_size = 18)}
      
      if(input$flip==TRUE){
        gg <- gg + coord_flip()
        gg <- gg + theme(axis.title.y = element_blank(),
                         axis.text.y.right= element_text(angle = -90, hjust = 0.5))
      }else{
        gg <- gg + theme(axis.title.x = element_blank())
      }
      
      
      plots$p1 <- gg
      gg
      
    }
  }
  
  # plot to the main panel
  output$jPlot <- renderPlot({
    print(plotInput())
  })  
  
  # output contrast interval method
  output$interval_text <- renderText({
    df <-datasetInput()
    if (is.null(df)) return(NULL)
    
    if(input$intervals.contrast!=1){ #bootstrap or bayes
      adjust_text <- 'no'
    }else{
      if(input$adjust==FALSE){adjust_text <- 'no'}else{
        if(input$contrasts.method==1){adjust_text <- 'Dunnet t approximation'}else{adjust_text <- 'Tukey HSD'}
      }
    }
    conf <- c(0.99, 0.95, 0.9)
    conf.contrast <- as.integer(conf[as.numeric(as.character(input$conf.contrast))]*100)
    out_text <- paste('contrasts with ',conf.contrast,'% CI using ',adjust_text, ' adjustment', sep='')
    out_text
  })
  
  # download
  # output$downloadPlot <- downloadHandler(
  #   filename = 'temp.png',
  #   content = function(file) {
  #     device <- function(..., width, height) grDevices::png(..., width = width, height = height, res = 300, units = "in")
  #     ggsave(file, plot = plotInput(), device = device)
  #   }
  # )
  
  output$downloadPlot = downloadHandler(
    filename = function() {"Hdotplot.pdf"},
    content = function(file) {
      pdf(file, width=input$width, height=input$height, onefile = TRUE)
      grid.arrange(plots$p1) 
      dev.off()
    }
  )
  
}


# Run the application 
shinyApp(ui = ui, server = server)

